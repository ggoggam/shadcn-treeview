{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tree-view",
  "title": "TreeView",
  "description": "A generic, accessible tree view with recursive expand/collapse, lazy loading, and drag-and-drop support.",
  "dependencies": [
    "@dnd-kit/react"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/tree-view/tree-view.tsx",
      "content": "\"use client\";\n\nimport {\n  createContext,\n  useContext,\n  useId,\n  useMemo,\n  useCallback,\n  useEffect,\n  useRef,\n} from \"react\";\nimport { DragDropProvider, DragOverlay } from \"@dnd-kit/react\";\nimport { cn } from \"@/lib/utils\";\nimport type {\n  TreeNodeData,\n  TreeNodeNested,\n  FlatTreeNode,\n  TreeDragEvent,\n  TreeNodeRenderProps,\n  LoadChildrenFn,\n  DropPosition,\n  MaybePromise,\n} from \"./lib/tree-types\";\nimport { TreeViewProvider } from \"./lib/tree-context\";\nimport { useTreeState } from \"./hooks/use-tree-state\";\nimport { useTreeKeyboard } from \"./hooks/use-tree-keyboard\";\nimport { useTreeLazy } from \"./hooks/use-tree-lazy\";\nimport { useTreeDnd } from \"./hooks/use-tree-dnd\";\nimport { TreeNodeRow } from \"./components/tree-node\";\nimport { TreeDropIndicator } from \"./components/tree-drop-indicator\";\n\n// ---------- DND Group Context ----------\n\ninterface DndGroupRegistration {\n  treeId: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleDragStart: (...args: any[]) => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleDragOver: (...args: any[]) => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleDragEnd: (...args: any[]) => void;\n  flatNodes: FlatTreeNode[];\n  /** Current DND projection state (set during handleDragOver) */\n  overId: string | null;\n  dropPosition: DropPosition | null;\n  projectedDepth: number | null;\n  projectedParentId: string | null;\n}\n\ninterface DndGroupContextValue {\n  register: (reg: DndGroupRegistration) => void;\n  unregister: (treeId: string) => void;\n}\n\n/**\n * Internal context for cross-tree DND registration.\n * null when not inside a TreeViewDndContext.\n */\nconst TreeViewDndGroupContext = createContext<DndGroupContextValue | null>(\n  null,\n);\n\n// ---------- TreeView Props ----------\n\nexport interface TreeViewProps<\n  T extends TreeNodeData = TreeNodeData,\n> extends Omit<\n  React.ComponentProps<\"div\">,\n  \"onChange\" | \"onDragStart\" | \"onDragEnd\" | \"onDragOver\"\n> {\n  /** Tree data in nested format */\n  items: TreeNodeNested<T>[];\n  /** Called when tree structure changes (reorder, DND) */\n  onItemsChange?: (items: TreeNodeNested<T>[]) => MaybePromise<void>;\n  /** Unique ID for this tree instance (auto-generated if not provided) */\n  treeId?: string;\n  /** Render function for each tree node */\n  renderNode: (props: TreeNodeRenderProps<T>) => React.ReactNode;\n  /** Render function for the drag overlay */\n  renderDragOverlay?: (props: TreeNodeRenderProps<T>) => React.ReactNode;\n  /** Async function to load children on expand */\n  loadChildren?: LoadChildrenFn<T>;\n  /** Error callback for lazy loading failures */\n  onLoadError?: (nodeId: string, error: Error) => MaybePromise<void>;\n  /** Selection mode */\n  selectionMode?: \"none\" | \"single\" | \"multiple\";\n  /** Controlled selected IDs */\n  selectedIds?: string[];\n  /** Selection change callback */\n  onSelectedIdsChange?: (ids: string[]) => MaybePromise<void>;\n  /** Controlled expanded IDs */\n  expandedIds?: string[];\n  /** Expansion change callback */\n  onExpandedIdsChange?: (ids: string[]) => MaybePromise<void>;\n  /** Expand all by default */\n  defaultExpandAll?: boolean;\n  /** Specific IDs to expand by default */\n  defaultExpandedIds?: string[];\n  /** Enable drag */\n  draggable?: boolean;\n  /** Enable drop */\n  droppable?: boolean;\n  /** Per-node drag guard */\n  canDrag?: (node: FlatTreeNode<T>) => boolean;\n  /** Per-operation drop guard */\n  canDrop?: (event: TreeDragEvent<T>) => boolean;\n  /** Auto-expand nodes on drag hover */\n  expandOnDragHover?: boolean;\n  /** Delay before auto-expand (ms) */\n  expandOnDragHoverDelay?: number;\n  /** Pixels per indent level */\n  indentationWidth?: number;\n  /**\n   * Horizontal offset (in px) from the left edge of each indentation column\n   * to the guide line. The guide line for depth `d` is positioned at\n   * `d * indentationWidth + guideLineOffset`.\n   *\n   * Set this to match the center of your chevron/toggle element.\n   * Default: 16 (aligns with 8px base padding + center of a 16px icon container).\n   */\n  guideLineOffset?: number;\n  /** Show vertical guide lines for nesting depth (default: true) */\n  showGuideLines?: boolean;\n  /**\n   * Shared DND group identifier for cross-tree drag-and-drop.\n   * Trees with the same dndGroup can exchange items.\n   * Defaults to the tree's own treeId (no cross-tree).\n   */\n  dndGroup?: string;\n  /** DND event callbacks */\n  onDragStart?: (event: TreeDragEvent<T>) => MaybePromise<void>;\n  onDragEnd?: (event: TreeDragEvent<T>) => MaybePromise<void>;\n}\n\n// ---------- TreeView Component ----------\n\nexport function TreeView<T extends TreeNodeData = TreeNodeData>({\n  items,\n  onItemsChange,\n  treeId: treeIdProp,\n  renderNode,\n  renderDragOverlay,\n  loadChildren,\n  onLoadError,\n  selectionMode = \"single\",\n  selectedIds: selectedIdsProp,\n  onSelectedIdsChange,\n  expandedIds: expandedIdsProp,\n  onExpandedIdsChange,\n  defaultExpandAll,\n  defaultExpandedIds,\n  draggable = false,\n  droppable = false,\n  canDrag,\n  canDrop,\n  expandOnDragHover = true,\n  expandOnDragHoverDelay = 500,\n  indentationWidth = 20,\n  guideLineOffset = 16,\n  showGuideLines = true,\n  dndGroup: dndGroupProp,\n  onDragStart,\n  onDragEnd,\n  className,\n  ...divProps\n}: TreeViewProps<T>) {\n  const autoId = useId();\n  const treeId = treeIdProp ?? autoId;\n  const dndGroupCtx = useContext(TreeViewDndGroupContext);\n  const isInsideDndGroup = dndGroupCtx !== null;\n  const dndGroup = dndGroupProp ?? treeId;\n\n  // Core state\n  const state = useTreeState<T>({\n    items,\n    onItemsChange,\n    selectionMode,\n    selectedIds: selectedIdsProp,\n    onSelectedIdsChange,\n    expandedIds: expandedIdsProp,\n    onExpandedIdsChange,\n    defaultExpandAll,\n    defaultExpandedIds,\n  });\n\n  // Lazy loading\n  const lazy = useTreeLazy<T>({\n    loadChildren,\n    insertChildren: state.insertChildren,\n    expand: state.expand,\n    onLoadError,\n  });\n\n  // DND\n  const dnd = useTreeDnd<T>({\n    treeId,\n    flatNodes: state.flatNodes,\n    visibleNodes: state.visibleNodes,\n    expandedIds: state.expandedIds,\n    selectedIds: state.selectedIds,\n    selectionMode,\n    indentationWidth,\n    canDrag,\n    canDrop,\n    onItemsChange,\n    onDragStart,\n    onDragEnd,\n    expandOnDragHover,\n    expandOnDragHoverDelay,\n    expand: state.expand,\n  });\n\n  // Register with group context for cross-tree DND event dispatch\n  const dndHandlersRef = useRef(dnd);\n  dndHandlersRef.current = dnd;\n  const flatNodesRef = useRef(state.flatNodes);\n  flatNodesRef.current = state.flatNodes;\n\n  useEffect(() => {\n    if (!dndGroupCtx || !(draggable || droppable)) return;\n    const reg: DndGroupRegistration = {\n      treeId,\n      get handleDragStart() {\n        return dndHandlersRef.current.handleDragStart;\n      },\n      get handleDragOver() {\n        return dndHandlersRef.current.handleDragOver;\n      },\n      get handleDragEnd() {\n        return dndHandlersRef.current.handleDragEnd;\n      },\n      get flatNodes() {\n        return flatNodesRef.current as FlatTreeNode[];\n      },\n      get overId() {\n        return dndHandlersRef.current.overId;\n      },\n      get dropPosition() {\n        return dndHandlersRef.current.dropPosition;\n      },\n      get projectedDepth() {\n        return dndHandlersRef.current.projectedDepth;\n      },\n      get projectedParentId() {\n        return dndHandlersRef.current.projectedParentId;\n      },\n    };\n    dndGroupCtx.register(reg);\n    return () => dndGroupCtx.unregister(treeId);\n  }, [dndGroupCtx, treeId, draggable, droppable]);\n\n  // Override toggleExpand to trigger lazy loading\n  const toggleExpand = useCallback(\n    (id: string) => {\n      const node = state.flatNodes.find((n) => n.id === id);\n      if (node && node.isGroup && !node.childrenLoaded && loadChildren) {\n        lazy.triggerLoad(node);\n      } else {\n        state.toggleExpand(id);\n      }\n    },\n    [state, lazy, loadChildren],\n  );\n\n  // Keyboard navigation\n  const keyboard = useTreeKeyboard<T>({\n    visibleNodes: state.visibleNodes,\n    flatNodes: state.flatNodes,\n    focusedId: state.focusedId,\n    expandedIds: state.expandedIds,\n    setFocused: state.setFocused,\n    toggleExpand,\n    expand: state.expand,\n    collapse: state.collapse,\n    select: state.select,\n    toggleSelect: state.toggleSelect,\n    selectRange: state.selectRange,\n    selectAll: state.selectAll,\n    selectionMode,\n  });\n\n  // Active node for drag overlay\n  const activeNode = dnd.activeId\n    ? (state.flatNodes.find((n) => n.id === dnd.activeId) ?? null)\n    : null;\n\n  // Context value\n  const contextValue = useMemo(\n    () => ({\n      treeId,\n      dndGroup,\n      flatNodes: state.flatNodes,\n      visibleNodes: state.visibleNodes,\n      expandedIds: state.expandedIds,\n      selectedIds: state.selectedIds,\n      focusedId: state.focusedId,\n      loadingIds: lazy.loadingIds,\n      activeId: dnd.activeId,\n      overId: dnd.overId,\n      dropPosition: dnd.dropPosition,\n      projectedDepth: dnd.projectedDepth,\n      indentationWidth,\n      selectionMode,\n      guideLineOffset,\n      showGuideLines,\n      draggable,\n      droppable,\n      canDrag,\n      toggleExpand,\n      select: state.select,\n      toggleSelect: state.toggleSelect,\n      selectRange: state.selectRange,\n      setFocused: state.setFocused,\n      renderNode,\n      renderDragOverlay,\n    }),\n    [\n      treeId,\n      dndGroup,\n      state.flatNodes,\n      state.visibleNodes,\n      state.expandedIds,\n      state.selectedIds,\n      state.focusedId,\n      lazy.loadingIds,\n      dnd.activeId,\n      dnd.overId,\n      dnd.dropPosition,\n      dnd.projectedDepth,\n      indentationWidth,\n      selectionMode,\n      guideLineOffset,\n      showGuideLines,\n      draggable,\n      droppable,\n      canDrag,\n      toggleExpand,\n      state.select,\n      state.toggleSelect,\n      state.selectRange,\n      state.setFocused,\n      renderNode,\n      renderDragOverlay,\n    ],\n  );\n\n  const treeContent = (\n    <TreeViewProvider value={contextValue}>\n      <div\n        {...divProps}\n        role=\"tree\"\n        aria-label={divProps[\"aria-label\"]}\n        aria-labelledby={divProps[\"aria-labelledby\"]}\n        aria-multiselectable={selectionMode === \"multiple\" || undefined}\n        aria-activedescendant={\n          state.focusedId ? `${treeId}-node-${state.focusedId}` : undefined\n        }\n        tabIndex={0}\n        data-slot=\"tree-view\"\n        className={cn(\"outline-none\", className)}\n        onKeyDown={keyboard.onKeyDown}\n      >\n        {state.visibleNodes.map((node, idx) => (\n          <TreeNodeRow<T> key={node.id} node={node} sortableIndex={idx} />\n        ))}\n      </div>\n    </TreeViewProvider>\n  );\n\n  const dragOverlayContent =\n    renderDragOverlay && activeNode ? (\n      <DragOverlay>\n        {renderDragOverlay({\n          node: activeNode,\n          isExpanded: state.expandedIds.has(activeNode.id),\n          isSelected: state.selectedIds.has(activeNode.id),\n          isFocused: false,\n          isLoading: false,\n          isDragging: true,\n          isDropTarget: false,\n          dropPosition: null,\n          depth: activeNode.depth,\n          hasChildren: activeNode.isGroup,\n          selectionMode,\n          toggle: () => {},\n          select: () => {},\n        })}\n      </DragOverlay>\n    ) : null;\n\n  // When inside a TreeViewDndContext, skip wrapping with our own DragDropProvider\n  // — the shared provider already exists above us.\n  if (isInsideDndGroup && (draggable || droppable)) {\n    return (\n      <>\n        {treeContent}\n        {dragOverlayContent}\n      </>\n    );\n  }\n\n  // Wrap with DragDropProvider if DND is enabled\n  if (draggable || droppable) {\n    return (\n      <DragDropProvider\n        onDragStart={dnd.handleDragStart}\n        onDragOver={dnd.handleDragOver}\n        onDragEnd={dnd.handleDragEnd}\n      >\n        {treeContent}\n        {dragOverlayContent}\n      </DragDropProvider>\n    );\n  }\n\n  return treeContent;\n}\n\n// ---------- TreeViewDndContext ----------\n\n/** Extra projection data attached to cross-tree drag end events. */\nexport interface CrossTreeDragInfo {\n  sourceTreeId: string;\n  targetTreeId: string;\n  dropPosition: DropPosition | null;\n  projectedDepth: number | null;\n  projectedParentId: string | null;\n}\n\nexport interface TreeViewDndContextProps {\n  children: React.ReactNode;\n  onDragStart?: (event: {\n    operation: { source: unknown; target: unknown };\n  }) => void;\n  onDragOver?: (event: {\n    operation: { source: unknown; target: unknown };\n  }) => void;\n  /**\n   * Called when a drag ends. For cross-tree moves, a `crossTree` property\n   * is attached with the target tree's projection (dropPosition, projectedDepth,\n   * projectedParentId) so the consumer can correctly place the node.\n   */\n  onDragEnd?: (event: {\n    operation: { source: unknown; target: unknown };\n    canceled: boolean;\n    crossTree?: CrossTreeDragInfo;\n  }) => void;\n}\n\n/**\n * Wraps multiple TreeView instances to enable cross-tree drag-and-drop.\n * Child TreeView instances should still set `draggable`/`droppable` to enable\n * per-node drag capabilities — the shared provider is handled here.\n */\nexport function TreeViewDndContext({\n  children,\n  onDragStart,\n  onDragOver,\n  onDragEnd,\n}: TreeViewDndContextProps) {\n  const registrationsRef = useRef(new Map<string, DndGroupRegistration>());\n\n  const groupCtx = useMemo<DndGroupContextValue>(\n    () => ({\n      register: (reg) => {\n        registrationsRef.current.set(reg.treeId, reg);\n      },\n      unregister: (treeId) => {\n        registrationsRef.current.delete(treeId);\n      },\n    }),\n    [],\n  );\n\n  // Find which registered tree owns a given node id\n  const findOwnerTree = useCallback(\n    (nodeId: string): DndGroupRegistration | undefined => {\n      for (const reg of registrationsRef.current.values()) {\n        if (reg.flatNodes.some((n) => n.id === nodeId)) return reg;\n      }\n      return undefined;\n    },\n    [],\n  );\n\n  const handleDragStart = useCallback(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (event: any) => {\n      const sourceId = event.operation?.source?.id;\n      if (sourceId != null) {\n        // Notify the source tree so it updates activeId\n        const owner = findOwnerTree(String(sourceId));\n        owner?.handleDragStart(event);\n      }\n      onDragStart?.(event);\n    },\n    [findOwnerTree, onDragStart],\n  );\n\n  const lastOverTreeRef = useRef<string | null>(null);\n\n  const handleDragOver = useCallback(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (event: any) => {\n      const targetId = event.operation?.target?.id;\n      if (targetId != null) {\n        const owner = findOwnerTree(String(targetId));\n        if (owner) {\n          // If target moved to a different tree, clear the previous tree's hover state\n          if (\n            lastOverTreeRef.current &&\n            lastOverTreeRef.current !== owner.treeId\n          ) {\n            const prev = registrationsRef.current.get(lastOverTreeRef.current);\n            if (prev) {\n              // Send a synthetic event with no target to clear overId\n              prev.handleDragOver({\n                ...event,\n                operation: { ...event.operation, target: null },\n              });\n            }\n          }\n          lastOverTreeRef.current = owner.treeId;\n          owner.handleDragOver(event);\n        }\n      }\n      onDragOver?.(event);\n    },\n    [findOwnerTree, onDragOver],\n  );\n\n  const handleDragEnd = useCallback(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (event: any) => {\n      const sourceId = event.operation?.source?.id;\n      const targetId = event.operation?.target?.id;\n\n      if (sourceId != null && targetId != null) {\n        const sourceTree = findOwnerTree(String(sourceId));\n        const targetTree = findOwnerTree(String(targetId));\n\n        if (\n          sourceTree &&\n          targetTree &&\n          sourceTree.treeId === targetTree.treeId\n        ) {\n          // Same-tree move — delegate to that tree's handler\n          sourceTree.handleDragEnd(event);\n        } else if (sourceTree && targetTree) {\n          // Cross-tree move — capture the target tree's projection before\n          // resetting state, then pass it to the consumer.\n          const crossTree: CrossTreeDragInfo = {\n            sourceTreeId: sourceTree.treeId,\n            targetTreeId: targetTree.treeId,\n            dropPosition: targetTree.dropPosition,\n            projectedDepth: targetTree.projectedDepth,\n            projectedParentId: targetTree.projectedParentId,\n          };\n\n          // Reset both trees' DND state\n          sourceTree.handleDragEnd({ ...event, canceled: true });\n          targetTree.handleDragEnd({ ...event, canceled: true });\n\n          lastOverTreeRef.current = null;\n          onDragEnd?.({ ...event, crossTree });\n          return;\n        }\n      } else {\n        // No valid source/target — reset all trees\n        for (const reg of registrationsRef.current.values()) {\n          reg.handleDragEnd({ ...event, canceled: true });\n        }\n      }\n\n      lastOverTreeRef.current = null;\n      onDragEnd?.(event);\n    },\n    [findOwnerTree, onDragEnd],\n  );\n\n  return (\n    <TreeViewDndGroupContext.Provider value={groupCtx}>\n      <DragDropProvider\n        onDragStart={handleDragStart}\n        onDragOver={handleDragOver}\n        onDragEnd={handleDragEnd}\n      >\n        {children}\n      </DragDropProvider>\n    </TreeViewDndGroupContext.Provider>\n  );\n}\n\n// Re-export types for consumers\nexport type {\n  TreeNodeData,\n  TreeNodeNested,\n  FlatTreeNode,\n  TreeDragEvent,\n  TreeNodeRenderProps,\n  LoadChildrenFn,\n  DropPosition,\n  MaybePromise,\n} from \"./lib/tree-types\";\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/tree-view/components/tree-node.tsx",
      "content": "\"use client\";\n\nimport { useMemo, useCallback } from \"react\";\nimport { useSortable } from \"@dnd-kit/react/sortable\";\nimport { cn } from \"@/lib/utils\";\nimport { useTreeViewContext } from \"../lib/tree-context\";\nimport { TreeDropIndicator } from \"./tree-drop-indicator\";\nimport type { TreeNodeData, FlatTreeNode } from \"../lib/tree-types\";\n\ninterface TreeNodeRowProps<T extends TreeNodeData = TreeNodeData> {\n  node: FlatTreeNode<T>;\n  sortableIndex: number;\n}\n\nexport function TreeNodeRow<T extends TreeNodeData = TreeNodeData>({\n  node,\n  sortableIndex,\n}: TreeNodeRowProps<T>) {\n  const ctx = useTreeViewContext<T>();\n  const {\n    treeId,\n    dndGroup,\n    flatNodes,\n    visibleNodes,\n    expandedIds,\n    selectedIds,\n    focusedId,\n    loadingIds,\n    activeId,\n    overId,\n    dropPosition,\n    projectedDepth,\n    indentationWidth,\n    selectionMode,\n    guideLineOffset,\n    showGuideLines,\n    draggable: isDraggableTree,\n    canDrag,\n    toggleExpand,\n    select,\n    toggleSelect,\n    selectRange,\n    renderNode,\n  } = ctx;\n\n  const isExpanded = expandedIds.has(node.id);\n  const isSelected = selectedIds.has(node.id);\n  const isFocused = focusedId === node.id;\n  const isLoading = loadingIds.has(node.id);\n  const isDragging = activeId === node.id;\n  const isDropTargetNode = overId === node.id;\n  const currentDropPosition = isDropTargetNode ? dropPosition : null;\n\n  const hasChildren =\n    node.isGroup &&\n    (node.childrenLoaded\n      ? flatNodes.some((n) => n.parentId === node.id)\n      : true);\n\n  const handleSelect = useCallback(\n    (event?: React.MouseEvent) => {\n      if (selectionMode === \"multiple\" && event) {\n        if (event.shiftKey) {\n          selectRange(node.id);\n          return;\n        }\n        if (event.metaKey || event.ctrlKey) {\n          toggleSelect(node.id);\n          return;\n        }\n      }\n      select(node.id);\n    },\n    [selectionMode, node.id, select, toggleSelect, selectRange],\n  );\n\n  const isDragDisabled = !isDraggableTree || (canDrag ? !canDrag(node) : false);\n\n  // Count siblings for aria-setsize\n  const siblingCount = flatNodes.filter(\n    (n) => n.parentId === node.parentId,\n  ).length;\n\n  const { ref, isDragSource } = useSortable({\n    id: node.id,\n    index: sortableIndex,\n    group: dndGroup,\n    disabled: isDragDisabled,\n    data: { node, treeId },\n    // Disable the default OptimisticSortingPlugin — we handle reordering\n    // manually in handleDragEnd via buildTree. The plugin would otherwise\n    // reorder DOM elements and mutate sortable indices during the drag,\n    // causing the target in onDragEnd to be stale/incorrect.\n    plugins: [],\n    transition: null,\n  });\n\n  const indicatorDepth = projectedDepth ?? node.depth;\n\n  // Compute which depth levels should show a vertical guide line.\n  // A line at level `d` means the ancestor subtree at that depth continues\n  // below this node (i.e., the ancestor has more siblings/children after).\n  const guideLines = useMemo(() => {\n    if (!showGuideLines || node.depth === 0) return [];\n\n    const lines: number[] = [];\n    // For each depth level from 0 to node.depth - 1, scan forward in\n    // visibleNodes to see if a node at that depth appears before a node at a\n    // shallower depth (which would close the subtree).\n    const continued = new Set<number>();\n    for (let i = sortableIndex + 1; i < visibleNodes.length; i++) {\n      const d = visibleNodes[i].depth;\n      if (d < node.depth) {\n        // We found a node shallower than current — mark this depth as\n        // continued (the ancestor at depth `d` has more siblings).\n        continued.add(d);\n        if (d === 0) break; // no deeper ancestors to check\n      }\n    }\n\n    for (let d = 0; d < node.depth; d++) {\n      if (continued.has(d)) lines.push(d);\n    }\n\n    // The immediate parent's line always shows if there is a subsequent\n    // sibling or cousin visible at the same depth or a node at parent depth.\n    // More accurately: the parent line shows if the current node is NOT the\n    // last child of its parent in the visible list.\n    const parentDepth = node.depth - 1;\n    if (!continued.has(parentDepth)) {\n      // Check if there's a subsequent sibling (same parentId)\n      for (let i = sortableIndex + 1; i < visibleNodes.length; i++) {\n        const n = visibleNodes[i];\n        if (n.depth <= parentDepth) break;\n        if (n.depth === node.depth && n.parentId === node.parentId) {\n          lines.push(parentDepth);\n          break;\n        }\n      }\n    }\n\n    return lines;\n  }, [showGuideLines, node.depth, node.parentId, sortableIndex, visibleNodes]);\n\n  return (\n    <div\n      ref={ref}\n      role=\"treeitem\"\n      id={`${treeId}-node-${node.id}`}\n      aria-expanded={node.isGroup ? isExpanded : undefined}\n      aria-selected={isSelected}\n      aria-level={node.depth + 1}\n      aria-setsize={siblingCount}\n      aria-posinset={node.index + 1}\n      data-slot=\"tree-node\"\n      data-node-id={node.id}\n      data-depth={node.depth}\n      data-dragging={isDragSource || undefined}\n      data-drop-target={isDropTargetNode || undefined}\n      data-drop-position={currentDropPosition}\n      className={cn(\n        \"relative outline-none\",\n        isDragSource && \"opacity-50\",\n        isDropTargetNode &&\n          currentDropPosition === \"inside\" &&\n          \"bg-accent/50 rounded-md\",\n      )}\n    >\n      {guideLines.map((d) => (\n        <span\n          key={d}\n          aria-hidden\n          data-slot=\"tree-guide-line\"\n          className=\"absolute top-0 bottom-0 w-px bg-border\"\n          style={{ left: d * indentationWidth + guideLineOffset }}\n        />\n      ))}\n      {renderNode({\n        node,\n        isExpanded,\n        isSelected,\n        isFocused,\n        isLoading,\n        isDragging: isDragSource,\n        isDropTarget: isDropTargetNode,\n        dropPosition: currentDropPosition,\n        depth: node.depth,\n        hasChildren,\n        selectionMode,\n        toggle: () => toggleExpand(node.id),\n        select: handleSelect,\n      })}\n      {isDropTargetNode && currentDropPosition === \"after\" && (\n        <TreeDropIndicator\n          depth={indicatorDepth}\n          indentationWidth={indentationWidth}\n        />\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/tree-view/components/tree-drop-indicator.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\n\ninterface TreeDropIndicatorProps {\n  depth: number;\n  indentationWidth: number;\n  className?: string;\n}\n\nexport function TreeDropIndicator({\n  depth,\n  indentationWidth,\n  className,\n}: TreeDropIndicatorProps) {\n  return (\n    <div\n      data-slot=\"tree-drop-indicator\"\n      className={cn(\"pointer-events-none absolute right-0 bottom-0 h-0.5 bg-primary\", className)}\n      style={{\n        left: depth * indentationWidth,\n      }}\n    />\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-state.ts",
      "content": "\"use client\";\n\nimport { useState, useMemo, useCallback, useRef } from \"react\";\nimport type { TreeNodeData, TreeNodeNested, FlatTreeNode, MaybePromise } from \"../lib/tree-types\";\nimport {\n  flattenTree,\n  buildTree,\n  getVisibleNodes,\n  getDescendantIds,\n} from \"../lib/tree-utils\";\n\nexport interface UseTreeStateOptions<T extends TreeNodeData> {\n  items: TreeNodeNested<T>[];\n  onItemsChange?: (items: TreeNodeNested<T>[]) => MaybePromise<void>;\n  selectionMode?: \"none\" | \"single\" | \"multiple\";\n  selectedIds?: string[];\n  onSelectedIdsChange?: (ids: string[]) => MaybePromise<void>;\n  expandedIds?: string[];\n  onExpandedIdsChange?: (ids: string[]) => MaybePromise<void>;\n  defaultExpandAll?: boolean;\n  defaultExpandedIds?: string[];\n}\n\nexport interface UseTreeStateReturn<T extends TreeNodeData> {\n  flatNodes: FlatTreeNode<T>[];\n  visibleNodes: FlatTreeNode<T>[];\n  expandedIds: Set<string>;\n  selectedIds: Set<string>;\n  focusedId: string | null;\n  toggleExpand: (id: string) => void;\n  expand: (id: string) => void;\n  collapse: (id: string) => void;\n  select: (id: string) => void;\n  toggleSelect: (id: string) => void;\n  selectRange: (id: string) => void;\n  selectAll: () => void;\n  setFocused: (id: string | null) => void;\n  setFlatNodes: (nodes: FlatTreeNode<T>[]) => void;\n  insertChildren: (parentId: string, children: TreeNodeNested<T>[]) => void;\n}\n\nfunction collectAllGroupIds<T extends TreeNodeData>(\n  nodes: TreeNodeNested<T>[]\n): string[] {\n  const ids: string[] = [];\n  for (const node of nodes) {\n    if (node.isGroup || (node.children && node.children.length > 0)) {\n      ids.push(node.id);\n    }\n    if (node.children) {\n      ids.push(...collectAllGroupIds(node.children));\n    }\n  }\n  return ids;\n}\n\nexport function useTreeState<T extends TreeNodeData>(\n  options: UseTreeStateOptions<T>\n): UseTreeStateReturn<T> {\n  const {\n    items,\n    onItemsChange,\n    selectionMode = \"none\",\n    selectedIds: controlledSelectedIds,\n    onSelectedIdsChange,\n    expandedIds: controlledExpandedIds,\n    onExpandedIdsChange,\n    defaultExpandAll = false,\n    defaultExpandedIds,\n  } = options;\n\n  // Flatten input items\n  const flatNodes = useMemo(() => flattenTree(items), [items]);\n\n  // Expanded state (controlled or uncontrolled)\n  const [internalExpandedIds, setInternalExpandedIds] = useState<Set<string>>(\n    () => {\n      if (defaultExpandAll) {\n        return new Set(collectAllGroupIds(items));\n      }\n      if (defaultExpandedIds) {\n        return new Set(defaultExpandedIds);\n      }\n      return new Set<string>();\n    }\n  );\n\n  const expandedIds = controlledExpandedIds\n    ? new Set(controlledExpandedIds)\n    : internalExpandedIds;\n\n  const setExpandedIds = useCallback(\n    (updater: Set<string> | ((prev: Set<string>) => Set<string>)) => {\n      const next = typeof updater === \"function\" ? updater(expandedIds) : updater;\n      if (onExpandedIdsChange) {\n        onExpandedIdsChange(Array.from(next));\n      }\n      if (!controlledExpandedIds) {\n        setInternalExpandedIds(next);\n      }\n    },\n    [expandedIds, onExpandedIdsChange, controlledExpandedIds]\n  );\n\n  // Selected state (controlled or uncontrolled)\n  const [internalSelectedIds, setInternalSelectedIds] = useState<Set<string>>(\n    new Set()\n  );\n\n  const selectedIds = controlledSelectedIds\n    ? new Set(controlledSelectedIds)\n    : internalSelectedIds;\n\n  const setSelectedIds = useCallback(\n    (updater: Set<string> | ((prev: Set<string>) => Set<string>)) => {\n      const next = typeof updater === \"function\" ? updater(selectedIds) : updater;\n      if (onSelectedIdsChange) {\n        onSelectedIdsChange(Array.from(next));\n      }\n      if (!controlledSelectedIds) {\n        setInternalSelectedIds(next);\n      }\n    },\n    [selectedIds, onSelectedIdsChange, controlledSelectedIds]\n  );\n\n  // Focused state\n  const [focusedId, setFocused] = useState<string | null>(null);\n\n  // Visible nodes (derived)\n  const visibleNodes = useMemo(\n    () => getVisibleNodes(flatNodes, expandedIds),\n    [flatNodes, expandedIds]\n  );\n\n  // Actions\n  const toggleExpand = useCallback(\n    (id: string) => {\n      setExpandedIds((prev) => {\n        const next = new Set(prev);\n        if (next.has(id)) {\n          next.delete(id);\n          // Also collapse descendants\n          const descendants = getDescendantIds(flatNodes, id);\n          for (const d of descendants) next.delete(d);\n        } else {\n          next.add(id);\n        }\n        return next;\n      });\n    },\n    [flatNodes, setExpandedIds]\n  );\n\n  const expand = useCallback(\n    (id: string) => {\n      setExpandedIds((prev) => {\n        if (prev.has(id)) return prev;\n        const next = new Set(prev);\n        next.add(id);\n        return next;\n      });\n    },\n    [setExpandedIds]\n  );\n\n  const collapse = useCallback(\n    (id: string) => {\n      setExpandedIds((prev) => {\n        if (!prev.has(id)) return prev;\n        const next = new Set(prev);\n        next.delete(id);\n        const descendants = getDescendantIds(flatNodes, id);\n        for (const d of descendants) next.delete(d);\n        return next;\n      });\n    },\n    [flatNodes, setExpandedIds]\n  );\n\n  // Anchor for Shift+Click range selection\n  const lastSelectedIdRef = useRef<string | null>(null);\n\n  const select = useCallback(\n    (id: string) => {\n      if (selectionMode === \"none\") return;\n      setSelectedIds(new Set([id]));\n      lastSelectedIdRef.current = id;\n    },\n    [selectionMode, setSelectedIds]\n  );\n\n  const toggleSelect = useCallback(\n    (id: string) => {\n      if (selectionMode === \"none\") return;\n      if (selectionMode === \"single\") {\n        setSelectedIds((prev) =>\n          prev.has(id) ? new Set() : new Set([id])\n        );\n      } else {\n        setSelectedIds((prev) => {\n          const next = new Set(prev);\n          if (next.has(id)) {\n            next.delete(id);\n          } else {\n            next.add(id);\n          }\n          return next;\n        });\n      }\n      lastSelectedIdRef.current = id;\n    },\n    [selectionMode, setSelectedIds]\n  );\n\n  const selectRange = useCallback(\n    (id: string) => {\n      if (selectionMode !== \"multiple\") return;\n      const anchor = lastSelectedIdRef.current;\n      if (!anchor) {\n        // No anchor — treat as plain select\n        setSelectedIds(new Set([id]));\n        lastSelectedIdRef.current = id;\n        return;\n      }\n      const anchorIdx = visibleNodes.findIndex((n) => n.id === anchor);\n      const targetIdx = visibleNodes.findIndex((n) => n.id === id);\n      if (anchorIdx === -1 || targetIdx === -1) {\n        setSelectedIds(new Set([id]));\n        lastSelectedIdRef.current = id;\n        return;\n      }\n      const start = Math.min(anchorIdx, targetIdx);\n      const end = Math.max(anchorIdx, targetIdx);\n      const rangeIds = new Set<string>();\n      for (let i = start; i <= end; i++) {\n        rangeIds.add(visibleNodes[i].id);\n      }\n      setSelectedIds(rangeIds);\n      // Do NOT update lastSelectedIdRef — anchor stays for subsequent Shift+Clicks\n    },\n    [selectionMode, visibleNodes, setSelectedIds]\n  );\n\n  const selectAll = useCallback(() => {\n    if (selectionMode !== \"multiple\") return;\n    setSelectedIds(new Set(visibleNodes.map((n) => n.id)));\n  }, [selectionMode, visibleNodes, setSelectedIds]);\n\n  // Mutation methods for DND and lazy loading\n  const onItemsChangeRef = useRef(onItemsChange);\n  onItemsChangeRef.current = onItemsChange;\n\n  const setFlatNodes = useCallback(\n    (nodes: FlatTreeNode<T>[]) => {\n      if (onItemsChangeRef.current) {\n        onItemsChangeRef.current(buildTree(nodes));\n      }\n    },\n    []\n  );\n\n  const insertChildren = useCallback(\n    (parentId: string, children: TreeNodeNested<T>[]) => {\n      // Rebuild items with children inserted under the parent\n      function insertInto(\n        nodes: TreeNodeNested<T>[]\n      ): TreeNodeNested<T>[] {\n        return nodes.map((node) => {\n          if (node.id === parentId) {\n            return {\n              ...node,\n              children: [...(node.children ?? []), ...children],\n            };\n          }\n          if (node.children) {\n            return { ...node, children: insertInto(node.children) };\n          }\n          return node;\n        });\n      }\n\n      if (onItemsChangeRef.current) {\n        onItemsChangeRef.current(insertInto(items));\n      }\n    },\n    [items]\n  );\n\n  return {\n    flatNodes,\n    visibleNodes,\n    expandedIds,\n    selectedIds,\n    focusedId,\n    toggleExpand,\n    expand,\n    collapse,\n    select,\n    toggleSelect,\n    selectRange,\n    selectAll,\n    setFocused,\n    setFlatNodes,\n    insertChildren,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-keyboard.ts",
      "content": "\"use client\";\n\nimport { useCallback, useRef } from \"react\";\nimport type { TreeNodeData, FlatTreeNode } from \"../lib/tree-types\";\n\nexport interface UseTreeKeyboardOptions<T extends TreeNodeData> {\n  visibleNodes: FlatTreeNode<T>[];\n  flatNodes: FlatTreeNode<T>[];\n  focusedId: string | null;\n  expandedIds: Set<string>;\n  setFocused: (id: string | null) => void;\n  toggleExpand: (id: string) => void;\n  expand: (id: string) => void;\n  collapse: (id: string) => void;\n  select: (id: string) => void;\n  toggleSelect: (id: string) => void;\n  selectRange: (id: string) => void;\n  selectAll: () => void;\n  selectionMode: \"none\" | \"single\" | \"multiple\";\n}\n\nexport function useTreeKeyboard<T extends TreeNodeData>(\n  options: UseTreeKeyboardOptions<T>\n): { onKeyDown: React.KeyboardEventHandler } {\n  const optionsRef = useRef(options);\n  optionsRef.current = options;\n\n  // Type-ahead buffer\n  const typeAheadBuffer = useRef(\"\");\n  const typeAheadTimer = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n\n  const onKeyDown: React.KeyboardEventHandler = useCallback((e) => {\n    const {\n      visibleNodes,\n      flatNodes,\n      focusedId,\n      expandedIds,\n      setFocused,\n      toggleExpand,\n      expand,\n      collapse,\n      select,\n      toggleSelect,\n      selectRange,\n      selectAll,\n      selectionMode,\n    } = optionsRef.current;\n\n    if (visibleNodes.length === 0) return;\n\n    const currentIndex = focusedId\n      ? visibleNodes.findIndex((n) => n.id === focusedId)\n      : -1;\n    const currentNode =\n      currentIndex >= 0 ? visibleNodes[currentIndex] : null;\n\n    switch (e.key) {\n      case \"ArrowDown\": {\n        e.preventDefault();\n        const nextIndex = Math.min(\n          currentIndex + 1,\n          visibleNodes.length - 1\n        );\n        const nextId = visibleNodes[nextIndex].id;\n        setFocused(nextId);\n        if (e.shiftKey && selectionMode === \"multiple\") {\n          selectRange(nextId);\n        }\n        break;\n      }\n\n      case \"ArrowUp\": {\n        e.preventDefault();\n        const prevIndex = Math.max(currentIndex - 1, 0);\n        const prevId = visibleNodes[prevIndex].id;\n        setFocused(prevId);\n        if (e.shiftKey && selectionMode === \"multiple\") {\n          selectRange(prevId);\n        }\n        break;\n      }\n\n      case \"ArrowRight\": {\n        e.preventDefault();\n        if (!currentNode) break;\n        if (currentNode.isGroup && !expandedIds.has(currentNode.id)) {\n          // Expand the node\n          expand(currentNode.id);\n        } else if (currentNode.isGroup && expandedIds.has(currentNode.id)) {\n          // Move to first child\n          const nextIndex = currentIndex + 1;\n          if (\n            nextIndex < visibleNodes.length &&\n            visibleNodes[nextIndex].parentId === currentNode.id\n          ) {\n            setFocused(visibleNodes[nextIndex].id);\n          }\n        }\n        break;\n      }\n\n      case \"ArrowLeft\": {\n        e.preventDefault();\n        if (!currentNode) break;\n        if (currentNode.isGroup && expandedIds.has(currentNode.id)) {\n          // Collapse the node\n          collapse(currentNode.id);\n        } else if (currentNode.parentId !== null) {\n          // Move focus to parent\n          setFocused(currentNode.parentId);\n        }\n        break;\n      }\n\n      case \"Home\": {\n        e.preventDefault();\n        if (visibleNodes.length > 0) {\n          const firstId = visibleNodes[0].id;\n          setFocused(firstId);\n          if (e.shiftKey && selectionMode === \"multiple\") {\n            selectRange(firstId);\n          }\n        }\n        break;\n      }\n\n      case \"End\": {\n        e.preventDefault();\n        if (visibleNodes.length > 0) {\n          const lastId = visibleNodes[visibleNodes.length - 1].id;\n          setFocused(lastId);\n          if (e.shiftKey && selectionMode === \"multiple\") {\n            selectRange(lastId);\n          }\n        }\n        break;\n      }\n\n      case \"Enter\": {\n        e.preventDefault();\n        if (currentNode) {\n          select(currentNode.id);\n        }\n        break;\n      }\n\n      case \" \": {\n        e.preventDefault();\n        if (currentNode) {\n          if (selectionMode === \"multiple\") {\n            toggleSelect(currentNode.id);\n          } else {\n            select(currentNode.id);\n          }\n        }\n        break;\n      }\n\n      case \"*\": {\n        // Expand all siblings of the focused node\n        e.preventDefault();\n        if (!currentNode) break;\n        for (const node of flatNodes) {\n          if (\n            node.parentId === currentNode.parentId &&\n            node.isGroup\n          ) {\n            expand(node.id);\n          }\n        }\n        break;\n      }\n\n      default: {\n        // Ctrl/Cmd+A: select all visible nodes\n        if (\n          e.key === \"a\" &&\n          (e.ctrlKey || e.metaKey) &&\n          selectionMode === \"multiple\"\n        ) {\n          e.preventDefault();\n          selectAll();\n          break;\n        }\n\n        // Type-ahead: single character\n        if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {\n          e.preventDefault();\n          clearTimeout(typeAheadTimer.current);\n          typeAheadBuffer.current += e.key.toLowerCase();\n\n          typeAheadTimer.current = setTimeout(() => {\n            typeAheadBuffer.current = \"\";\n          }, 500);\n\n          // Search from current position forward, wrapping around\n          const startIndex = currentIndex + 1;\n          for (let i = 0; i < visibleNodes.length; i++) {\n            const idx = (startIndex + i) % visibleNodes.length;\n            const node = visibleNodes[idx];\n            // Use a simple heuristic: check if any string value in data starts with the buffer\n            const label = getNodeLabel(node);\n            if (label.toLowerCase().startsWith(typeAheadBuffer.current)) {\n              setFocused(node.id);\n              break;\n            }\n          }\n        }\n        break;\n      }\n    }\n  }, []);\n\n  return { onKeyDown };\n}\n\n/**\n * Best-effort label extraction from node data for type-ahead.\n */\nfunction getNodeLabel<T extends TreeNodeData>(node: FlatTreeNode<T>): string {\n  const data = node.data as Record<string, unknown>;\n  // Try common label fields\n  for (const key of [\"label\", \"name\", \"title\", \"text\"]) {\n    if (typeof data[key] === \"string\") return data[key];\n  }\n  // Fallback to first string value\n  for (const value of Object.values(data)) {\n    if (typeof value === \"string\") return value;\n  }\n  return node.id;\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-dnd.ts",
      "content": "\"use client\";\n\nimport { useState, useCallback, useRef } from \"react\";\nimport type {\n  TreeNodeData,\n  FlatTreeNode,\n  DropPosition,\n  TreeDragEvent,\n  MaybePromise,\n} from \"../lib/tree-types\";\nimport {\n  getDescendantIds,\n  getProjection,\n  removeNodes,\n  buildTree,\n} from \"../lib/tree-utils\";\nimport type {\n  DragStartEvent,\n  DragOverEvent,\n  DragEndEvent,\n} from \"@dnd-kit/react\";\n\nexport interface UseTreeDndOptions<T extends TreeNodeData> {\n  treeId: string;\n  flatNodes: FlatTreeNode<T>[];\n  visibleNodes: FlatTreeNode<T>[];\n  expandedIds: Set<string>;\n  selectedIds: Set<string>;\n  selectionMode: \"none\" | \"single\" | \"multiple\";\n  indentationWidth: number;\n  canDrag?: (node: FlatTreeNode<T>) => boolean;\n  canDrop?: (event: TreeDragEvent<T>) => boolean;\n  onItemsChange?: (items: import(\"../lib/tree-types\").TreeNodeNested<T>[]) => MaybePromise<void>;\n  onDragStart?: (event: TreeDragEvent<T>) => MaybePromise<void>;\n  onDragEnd?: (event: TreeDragEvent<T>) => MaybePromise<void>;\n  expandOnDragHover?: boolean;\n  expandOnDragHoverDelay?: number;\n  expand: (id: string) => void;\n}\n\nexport interface UseTreeDndReturn {\n  activeId: string | null;\n  overId: string | null;\n  dropPosition: DropPosition | null;\n  projectedDepth: number | null;\n  projectedParentId: string | null;\n  handleDragStart: DragStartEvent;\n  handleDragOver: DragOverEvent;\n  handleDragEnd: DragEndEvent;\n}\n\nexport function useTreeDnd<T extends TreeNodeData>(\n  options: UseTreeDndOptions<T>\n): UseTreeDndReturn {\n  const {\n    treeId,\n    flatNodes,\n    visibleNodes,\n    expandedIds,\n    selectedIds,\n    selectionMode,\n    indentationWidth,\n    canDrop,\n    onItemsChange,\n    onDragStart,\n    onDragEnd,\n    expandOnDragHover = true,\n    expandOnDragHoverDelay = 500,\n    expand,\n  } = options;\n\n  const [activeId, setActiveId] = useState<string | null>(null);\n  const [overId, setOverId] = useState<string | null>(null);\n  const [dropPosition, setDropPosition] = useState<DropPosition | null>(null);\n  const [projectedDepth, setProjectedDepth] = useState<number | null>(null);\n  const [projectedParentId, setProjectedParentId] = useState<string | null>(\n    null\n  );\n\n  // Refs to avoid stale closures in handleDragEnd — state updates from\n  // handleDragOver may not have committed by the time handleDragEnd fires.\n  const dropPositionRef = useRef<DropPosition | null>(null);\n  const projectedDepthRef = useRef<number | null>(null);\n  const projectedParentIdRef = useRef<string | null>(null);\n\n  const hoverTimerRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  const hoverTargetRef = useRef<string | null>(null);\n  const offsetRef = useRef({ x: 0, y: 0 });\n\n  const handleDragStart: DragStartEvent = useCallback(\n    (event) => {\n      const source = event.operation.source;\n      if (!source) return;\n\n      const sourceNode = flatNodes.find((n) => n.id === source.id);\n      if (!sourceNode) return;\n\n      setActiveId(String(source.id));\n      offsetRef.current = { x: 0, y: 0 };\n\n      if (onDragStart && sourceNode) {\n        onDragStart({\n          source: sourceNode,\n          sourceTreeId: treeId,\n          target: sourceNode,\n          targetTreeId: treeId,\n          position: \"before\",\n          projectedDepth: sourceNode.depth,\n        });\n      }\n    },\n    [flatNodes, treeId, onDragStart]\n  );\n\n  const handleDragOver: DragOverEvent = useCallback(\n    (event) => {\n      const { source, target } = event.operation;\n      if (!source || !target) {\n        setOverId(null);\n        setDropPosition(null);\n        return;\n      }\n\n      const targetId = String(target.id);\n      setOverId(targetId);\n\n      // Track cumulative offset for depth projection\n      const transform = event.operation.transform;\n      if (transform) {\n        offsetRef.current = { x: transform.x, y: transform.y };\n      }\n\n      // Calculate projection\n      const projection = getProjection(\n        flatNodes,\n        visibleNodes,\n        String(source.id),\n        targetId,\n        offsetRef.current.x,\n        indentationWidth\n      );\n\n      setProjectedDepth(projection.depth);\n      setProjectedParentId(projection.parentId);\n      projectedDepthRef.current = projection.depth;\n      projectedParentIdRef.current = projection.parentId;\n\n      // Determine drop position\n      const targetNode = flatNodes.find((n) => n.id === targetId);\n      if (targetNode) {\n        // Check if the target is an expanded group with no visible children.\n        // In that case, hovering over it should always mean \"inside\" since\n        // there are no children to sort between. We also override the\n        // projected depth/parent so handleDragEnd places the node correctly.\n        const isExpandedEmptyGroup =\n          targetNode.isGroup &&\n          expandedIds.has(targetId) &&\n          !visibleNodes.some((n) => n.parentId === targetId);\n\n        const position: DropPosition =\n          targetNode.isGroup &&\n          (projection.parentId === targetId || isExpandedEmptyGroup)\n            ? \"inside\"\n            : \"after\";\n\n        if (isExpandedEmptyGroup && position === \"inside\") {\n          const correctedDepth = targetNode.depth + 1;\n          setProjectedDepth(correctedDepth);\n          setProjectedParentId(targetId);\n          projectedDepthRef.current = correctedDepth;\n          projectedParentIdRef.current = targetId;\n        }\n\n        setDropPosition(position);\n        dropPositionRef.current = position;\n      }\n\n      // Auto-expand on hover\n      if (expandOnDragHover && targetId !== hoverTargetRef.current) {\n        clearTimeout(hoverTimerRef.current);\n        hoverTargetRef.current = targetId;\n\n        const hoverNode = flatNodes.find((n) => n.id === targetId);\n        if (\n          hoverNode?.isGroup &&\n          !expandedIds.has(targetId) &&\n          targetId !== String(source.id)\n        ) {\n          hoverTimerRef.current = setTimeout(() => {\n            expand(targetId);\n          }, expandOnDragHoverDelay);\n        }\n      }\n    },\n    [\n      flatNodes,\n      visibleNodes,\n      indentationWidth,\n      expandedIds,\n      expandOnDragHover,\n      expandOnDragHoverDelay,\n      expand,\n    ]\n  );\n\n  const handleDragEnd: DragEndEvent = useCallback(\n    (event) => {\n      clearTimeout(hoverTimerRef.current);\n      hoverTargetRef.current = null;\n\n      const { source, target } = event.operation;\n      const canceled = event.canceled;\n\n      // Read from refs to avoid stale closures\n      const currentDropPosition = dropPositionRef.current;\n      const currentProjectedDepth = projectedDepthRef.current;\n      const currentProjectedParentId = projectedParentIdRef.current;\n\n      const resetState = () => {\n        setActiveId(null);\n        setOverId(null);\n        setDropPosition(null);\n        setProjectedDepth(null);\n        setProjectedParentId(null);\n        dropPositionRef.current = null;\n        projectedDepthRef.current = null;\n        projectedParentIdRef.current = null;\n      };\n\n      if (canceled || !source || !target) {\n        resetState();\n        return;\n      }\n\n      const sourceNode = flatNodes.find((n) => n.id === source.id);\n      const targetNode = flatNodes.find((n) => n.id === target.id);\n\n      if (!sourceNode || !targetNode) {\n        resetState();\n        return;\n      }\n\n      // Check canDrop\n      const dragEvent: TreeDragEvent<T> = {\n        source: sourceNode,\n        sourceTreeId: treeId,\n        target: targetNode,\n        targetTreeId: treeId,\n        position: currentDropPosition ?? \"after\",\n        projectedDepth: currentProjectedDepth ?? targetNode.depth,\n      };\n\n      if (canDrop && !canDrop(dragEvent)) {\n        resetState();\n        return;\n      }\n\n      // Perform the move\n      if (onItemsChange) {\n        // Determine which root-level nodes to move. In multiple selection mode,\n        // if the dragged node is part of the selection, move all selected nodes.\n        // Filter out nodes whose ancestor is also selected (they move with their parent).\n        const movingMultiple =\n          selectionMode === \"multiple\" &&\n          selectedIds.has(sourceNode.id) &&\n          selectedIds.size > 1;\n\n        let rootIdsToMove: string[];\n        if (movingMultiple) {\n          // Build a set of all selected ids and their descendants\n          const allDescendants = new Set<string>();\n          for (const id of selectedIds) {\n            for (const d of getDescendantIds(flatNodes, id)) {\n              allDescendants.add(d);\n            }\n          }\n          // Root-level selected = selected but not a descendant of another selected node\n          rootIdsToMove = Array.from(selectedIds).filter(\n            (id) => !allDescendants.has(id)\n          );\n        } else {\n          rootIdsToMove = [sourceNode.id];\n        }\n\n        // Collect all nodes to move (roots + their descendants), preserving flat order\n        const allIdsToMove = new Set<string>();\n        for (const rootId of rootIdsToMove) {\n          allIdsToMove.add(rootId);\n          for (const d of getDescendantIds(flatNodes, rootId)) {\n            allIdsToMove.add(d);\n          }\n        }\n        const draggedNodes = flatNodes.filter((n) => allIdsToMove.has(n.id));\n\n        // Remove all dragged nodes from the tree\n        const remaining = removeNodes(flatNodes, rootIdsToMove);\n\n        // For each root being moved, update depth/parentId relative to the source node.\n        // The source node goes to the projected position; other roots maintain their\n        // relative depth offsets from the source.\n        const depthDiff = (currentProjectedDepth ?? 0) - sourceNode.depth;\n        const updatedDragged = draggedNodes.map((n) => {\n          if (rootIdsToMove.includes(n.id)) {\n            // Root node of a moved subtree\n            return {\n              ...n,\n              depth: n.depth + depthDiff,\n              parentId: currentProjectedParentId,\n            };\n          }\n          // Descendant — just shift depth\n          return {\n            ...n,\n            depth: n.depth + depthDiff,\n          };\n        });\n\n        // Insert at the correct position\n        let insertAt = remaining.length;\n        const targetFlatIdx = remaining.findIndex(\n          (n) => n.id === target.id\n        );\n        if (targetFlatIdx >= 0) {\n          if (currentDropPosition === \"inside\") {\n            // Insert as first child of the target (right after the target node)\n            insertAt = targetFlatIdx + 1;\n          } else {\n            // \"after\" — insert after the target and all its descendants\n            let i = targetFlatIdx + 1;\n            while (\n              i < remaining.length &&\n              remaining[i].depth > remaining[targetFlatIdx].depth\n            ) {\n              i++;\n            }\n            insertAt = i;\n          }\n        }\n\n        const result = [\n          ...remaining.slice(0, insertAt),\n          ...updatedDragged,\n          ...remaining.slice(insertAt),\n        ];\n\n        onItemsChange(buildTree(result));\n      }\n\n      if (onDragEnd) {\n        onDragEnd(dragEvent);\n      }\n\n      resetState();\n    },\n    [\n      flatNodes,\n      treeId,\n      selectedIds,\n      selectionMode,\n      canDrop,\n      onItemsChange,\n      onDragEnd,\n    ]\n  );\n\n  return {\n    activeId,\n    overId,\n    dropPosition,\n    projectedDepth,\n    projectedParentId,\n    handleDragStart,\n    handleDragOver,\n    handleDragEnd,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-lazy.ts",
      "content": "\"use client\";\n\nimport { useState, useCallback, useRef } from \"react\";\nimport type {\n  TreeNodeData,\n  TreeNodeNested,\n  FlatTreeNode,\n  LoadChildrenFn,\n  MaybePromise,\n} from \"../lib/tree-types\";\n\nexport interface UseTreeLazyOptions<T extends TreeNodeData> {\n  loadChildren?: LoadChildrenFn<T>;\n  insertChildren: (parentId: string, children: TreeNodeNested<T>[]) => void;\n  expand: (id: string) => void;\n  onLoadError?: (nodeId: string, error: Error) => MaybePromise<void>;\n}\n\nexport interface UseTreeLazyReturn {\n  loadingIds: Set<string>;\n  isLoading: (id: string) => boolean;\n  triggerLoad: (node: FlatTreeNode) => void;\n}\n\nexport function useTreeLazy<T extends TreeNodeData>(\n  options: UseTreeLazyOptions<T>\n): UseTreeLazyReturn {\n  const { loadChildren, insertChildren, expand, onLoadError } = options;\n  const [loadingIds, setLoadingIds] = useState<Set<string>>(new Set());\n  const inFlightRef = useRef<Set<string>>(new Set());\n\n  const isLoading = useCallback(\n    (id: string) => loadingIds.has(id),\n    [loadingIds]\n  );\n\n  const triggerLoad = useCallback(\n    (node: FlatTreeNode) => {\n      if (!loadChildren) return;\n      if (!node.isGroup) return;\n      if (node.childrenLoaded) return;\n      if (inFlightRef.current.has(node.id)) return;\n\n      inFlightRef.current.add(node.id);\n      setLoadingIds((prev) => {\n        const next = new Set(prev);\n        next.add(node.id);\n        return next;\n      });\n\n      loadChildren(node as FlatTreeNode<T>)\n        .then((children) => {\n          insertChildren(node.id, children);\n          expand(node.id);\n        })\n        .catch((error) => {\n          if (onLoadError) {\n            onLoadError(\n              node.id,\n              error instanceof Error ? error : new Error(String(error))\n            );\n          }\n        })\n        .finally(() => {\n          inFlightRef.current.delete(node.id);\n          setLoadingIds((prev) => {\n            const next = new Set(prev);\n            next.delete(node.id);\n            return next;\n          });\n        });\n    },\n    [loadChildren, insertChildren, expand, onLoadError]\n  );\n\n  return { loadingIds, isLoading, triggerLoad };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/lib/tree-types.ts",
      "content": "import type React from \"react\";\n\n/**\n * Base constraint for user-provided tree node data.\n * Users extend this with their own properties.\n * Using an object constraint to allow interfaces without index signatures.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport type TreeNodeData = {};\n\n/**\n * Nested input format — what users pass as tree data.\n */\nexport interface TreeNodeNested<T extends TreeNodeData = TreeNodeData> {\n  /** Unique identifier for this node */\n  id: string;\n  /** Custom user data */\n  data: T;\n  /** Whether this node can have children (shows expand affordance even when empty) */\n  isGroup?: boolean;\n  /** Child nodes. Omit or undefined for lazy-loaded groups. */\n  children?: TreeNodeNested<T>[];\n}\n\n/**\n * Internal flat representation used by the tree engine.\n */\nexport interface FlatTreeNode<T extends TreeNodeData = TreeNodeData> {\n  id: string;\n  data: T;\n  isGroup: boolean;\n  /** Whether children have been loaded (for lazy loading). true if children array was provided. */\n  childrenLoaded: boolean;\n  parentId: string | null;\n  depth: number;\n  /** Position among siblings (0-based) */\n  index: number;\n}\n\n/**\n * Drop position relative to a target node.\n */\nexport type DropPosition = \"before\" | \"after\" | \"inside\";\n\n/**\n * Information passed to DND event handlers.\n */\nexport interface TreeDragEvent<T extends TreeNodeData = TreeNodeData> {\n  /** The node being dragged */\n  source: FlatTreeNode<T>;\n  /** The source tree instance id */\n  sourceTreeId: string;\n  /** The target node (drop target) */\n  target: FlatTreeNode<T>;\n  /** The target tree instance id */\n  targetTreeId: string;\n  /** Where relative to target */\n  position: DropPosition;\n  /** Projected depth after drop */\n  projectedDepth: number;\n}\n\n/**\n * Callback for lazy loading children.\n */\nexport type MaybePromise<T> = T | Promise<T>;\n\n/**\n * Callback for lazy loading children.\n */\nexport type LoadChildrenFn<T extends TreeNodeData = TreeNodeData> = (\n  node: FlatTreeNode<T>\n) => Promise<TreeNodeNested<T>[]>;\n\n/**\n * Render function props for custom node rendering.\n */\nexport interface TreeNodeRenderProps<T extends TreeNodeData = TreeNodeData> {\n  node: FlatTreeNode<T>;\n  isExpanded: boolean;\n  isSelected: boolean;\n  isFocused: boolean;\n  isLoading: boolean;\n  isDragging: boolean;\n  isDropTarget: boolean;\n  dropPosition: DropPosition | null;\n  depth: number;\n  hasChildren: boolean;\n  selectionMode: \"none\" | \"single\" | \"multiple\";\n  toggle: () => void;\n  select: (event?: React.MouseEvent) => void;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/tree-view/lib/tree-utils.ts",
      "content": "import type { TreeNodeData, TreeNodeNested, FlatTreeNode } from \"./tree-types\";\n\n/**\n * Convert nested tree structure to flat array with parentId references.\n */\nexport function flattenTree<T extends TreeNodeData>(\n  nodes: TreeNodeNested<T>[],\n  parentId: string | null = null,\n  depth: number = 0\n): FlatTreeNode<T>[] {\n  const result: FlatTreeNode<T>[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const hasChildren = node.children !== undefined && node.children.length > 0;\n\n    result.push({\n      id: node.id,\n      data: node.data,\n      isGroup: node.isGroup ?? hasChildren,\n      childrenLoaded: node.children !== undefined,\n      parentId,\n      depth,\n      index: i,\n    });\n\n    if (node.children) {\n      result.push(...flattenTree(node.children, node.id, depth + 1));\n    }\n  }\n\n  return result;\n}\n\n/**\n * Convert flat array back to nested tree structure.\n */\nexport function buildTree<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[]\n): TreeNodeNested<T>[] {\n  const nodeMap = new Map<\n    string,\n    TreeNodeNested<T> & { _hasChildren: boolean }\n  >();\n  const roots: TreeNodeNested<T>[] = [];\n\n  // Create all nodes first\n  for (const flat of flatNodes) {\n    nodeMap.set(flat.id, {\n      id: flat.id,\n      data: flat.data,\n      isGroup: flat.isGroup || undefined,\n      children: flat.childrenLoaded ? [] : undefined,\n      _hasChildren: false,\n    });\n  }\n\n  // Build parent-child relationships\n  for (const flat of flatNodes) {\n    const node = nodeMap.get(flat.id)!;\n    // Remove internal marker\n    const { _hasChildren: _, ...cleanNode } = node;\n\n    if (flat.parentId === null) {\n      roots.push(cleanNode);\n    } else {\n      const parent = nodeMap.get(flat.parentId);\n      if (parent) {\n        if (!parent.children) parent.children = [];\n        parent.children.push(cleanNode);\n        parent._hasChildren = true;\n      }\n    }\n  }\n\n  return roots;\n}\n\n/**\n * Get only the visible nodes (ancestors all expanded).\n */\nexport function getVisibleNodes<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  expandedIds: Set<string>\n): FlatTreeNode<T>[] {\n  const result: FlatTreeNode<T>[] = [];\n  const collapsedAncestors = new Set<string>();\n\n  for (const node of flatNodes) {\n    // Skip if any ancestor is collapsed\n    if (node.parentId !== null && collapsedAncestors.has(node.parentId)) {\n      // This node is hidden; if it's a group, its descendants are also hidden\n      collapsedAncestors.add(node.id);\n      continue;\n    }\n\n    result.push(node);\n\n    // If this node is a group and not expanded, mark it as collapsed ancestor\n    if (node.isGroup && !expandedIds.has(node.id)) {\n      collapsedAncestors.add(node.id);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Get all descendant IDs of a node.\n */\nexport function getDescendantIds<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  parentId: string\n): string[] {\n  const descendants: string[] = [];\n  const parentSet = new Set<string>([parentId]);\n\n  for (const node of flatNodes) {\n    if (node.parentId !== null && parentSet.has(node.parentId)) {\n      descendants.push(node.id);\n      parentSet.add(node.id);\n    }\n  }\n\n  return descendants;\n}\n\n/**\n * Get all ancestor IDs of a node (from immediate parent to root).\n */\nexport function getAncestorIds<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  nodeId: string\n): string[] {\n  const ancestors: string[] = [];\n  const nodeMap = new Map<string, FlatTreeNode<T>>();\n\n  for (const node of flatNodes) {\n    nodeMap.set(node.id, node);\n  }\n\n  let current = nodeMap.get(nodeId);\n  while (current && current.parentId !== null) {\n    ancestors.push(current.parentId);\n    current = nodeMap.get(current.parentId);\n  }\n\n  return ancestors;\n}\n\n/**\n * Get the count of siblings for a node (nodes with the same parentId).\n */\nexport function getSiblingCount<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  parentId: string | null\n): number {\n  let count = 0;\n  for (const node of flatNodes) {\n    if (node.parentId === parentId) count++;\n  }\n  return count;\n}\n\n/**\n * Calculate the projected depth and parentId for a DND drop operation.\n * Based on horizontal cursor offset from the active item's original position.\n */\nexport function getProjection<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  visibleNodes: FlatTreeNode<T>[],\n  activeId: string,\n  overId: string,\n  offsetX: number,\n  indentWidth: number\n): { depth: number; parentId: string | null } {\n  const overIndex = visibleNodes.findIndex((n) => n.id === overId);\n\n  if (overIndex === -1) {\n    return { depth: 0, parentId: null };\n  }\n\n  const overNode = visibleNodes[overIndex];\n  const activeNode = flatNodes.find((n) => n.id === activeId);\n\n  // When the source node isn't in this tree (cross-tree drag),\n  // use the over node's depth as the base for projection.\n  const baseDepth = activeNode ? activeNode.depth : overNode.depth;\n  const depthDelta = Math.round(offsetX / indentWidth);\n  const projectedDepth = Math.max(0, baseDepth + depthDelta);\n\n  // Clamp the projected depth based on surrounding nodes\n  const nextNode = visibleNodes[overIndex + 1];\n  const maxDepth = overNode.isGroup\n    ? overNode.depth + 1\n    : overNode.depth;\n  const minDepth = nextNode ? nextNode.depth : 0;\n  const clampedDepth = Math.min(Math.max(projectedDepth, minDepth), maxDepth);\n\n  // Find the parent at the projected depth\n  let parentId: string | null = null;\n  if (clampedDepth > 0) {\n    // Walk backwards from overNode to find a node at (clampedDepth - 1) that could be parent\n    for (let i = overIndex; i >= 0; i--) {\n      if (visibleNodes[i].depth === clampedDepth - 1) {\n        parentId = visibleNodes[i].id;\n        break;\n      }\n    }\n  }\n\n  return { depth: clampedDepth, parentId };\n}\n\n/**\n * Remove nodes by IDs (and all their descendants).\n */\nexport function removeNodes<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  ids: string[]\n): FlatTreeNode<T>[] {\n  const removeSet = new Set(ids);\n\n  // Also collect all descendants of removed nodes\n  for (const node of flatNodes) {\n    if (node.parentId !== null && removeSet.has(node.parentId)) {\n      removeSet.add(node.id);\n    }\n  }\n\n  const result = flatNodes.filter((n) => !removeSet.has(n.id));\n\n  // Recompute sibling indices\n  return reindexSiblings(result);\n}\n\n/**\n * Insert flat nodes into the tree at a specific position.\n */\nexport function insertNodes<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  nodesToInsert: FlatTreeNode<T>[],\n  targetParentId: string | null,\n  targetIndex: number\n): FlatTreeNode<T>[] {\n  // Find the insertion point in the flat array\n  let insertAt = flatNodes.length; // default: end\n\n  // Find position of the target sibling\n  let siblingCount = 0;\n  for (let i = 0; i < flatNodes.length; i++) {\n    if (flatNodes[i].parentId === targetParentId) {\n      if (siblingCount === targetIndex) {\n        insertAt = i;\n        break;\n      }\n      siblingCount++;\n    }\n  }\n\n  const result = [\n    ...flatNodes.slice(0, insertAt),\n    ...nodesToInsert,\n    ...flatNodes.slice(insertAt),\n  ];\n\n  return reindexSiblings(result);\n}\n\n/**\n * Recompute sibling indices after structural changes.\n */\nfunction reindexSiblings<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[]\n): FlatTreeNode<T>[] {\n  const indexCounters = new Map<string | null, number>();\n\n  return flatNodes.map((node) => {\n    const key = node.parentId;\n    const currentIndex = indexCounters.get(key) ?? 0;\n    indexCounters.set(key, currentIndex + 1);\n    return { ...node, index: currentIndex };\n  });\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/tree-view/lib/tree-context.ts",
      "content": "\"use client\";\n\nimport { createContext, useContext } from \"react\";\nimport type { TreeNodeData, FlatTreeNode, DropPosition } from \"./tree-types\";\n\n/**\n * Internal context for a single TreeView instance.\n * Shared between TreeView and its TreeNode children.\n */\nexport interface TreeViewContextValue<T extends TreeNodeData = TreeNodeData> {\n  treeId: string;\n  dndGroup: string;\n  flatNodes: FlatTreeNode<T>[];\n  visibleNodes: FlatTreeNode<T>[];\n  expandedIds: Set<string>;\n  selectedIds: Set<string>;\n  focusedId: string | null;\n  loadingIds: Set<string>;\n  activeId: string | null;\n  overId: string | null;\n  dropPosition: DropPosition | null;\n  projectedDepth: number | null;\n  indentationWidth: number;\n  selectionMode: \"none\" | \"single\" | \"multiple\";\n  guideLineOffset: number;\n  showGuideLines: boolean;\n  draggable: boolean;\n  droppable: boolean;\n  canDrag?: (node: FlatTreeNode<T>) => boolean;\n  toggleExpand: (id: string) => void;\n  select: (id: string) => void;\n  toggleSelect: (id: string) => void;\n  selectRange: (id: string) => void;\n  setFocused: (id: string | null) => void;\n  renderNode: (\n    props: import(\"./tree-types\").TreeNodeRenderProps<T>,\n  ) => React.ReactNode;\n  renderDragOverlay?: (\n    props: import(\"./tree-types\").TreeNodeRenderProps<T>,\n  ) => React.ReactNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst TreeViewContext = createContext<TreeViewContextValue<any> | null>(null);\n\nexport const TreeViewProvider = TreeViewContext.Provider;\n\nexport function useTreeViewContext<\n  T extends TreeNodeData = TreeNodeData,\n>(): TreeViewContextValue<T> {\n  const ctx = useContext(TreeViewContext);\n  if (!ctx) {\n    throw new Error(\"useTreeViewContext must be used within a <TreeView>\");\n  }\n  return ctx as TreeViewContextValue<T>;\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}
