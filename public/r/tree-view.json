{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tree-view",
  "title": "Tree View",
  "description": "A generic, accessible tree view with recursive expand/collapse, lazy loading, and drag-and-drop support.",
  "dependencies": [
    "@dnd-kit/react"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/tree-view/tree-view.tsx",
      "content": "\"use client\";\n\nimport { useId, useMemo, useCallback } from \"react\";\nimport { DragDropProvider, DragOverlay } from \"@dnd-kit/react\";\nimport { cn } from \"@/lib/utils\";\nimport type {\n  TreeNodeData,\n  TreeNodeNested,\n  FlatTreeNode,\n  TreeDragEvent,\n  TreeNodeRenderProps,\n  LoadChildrenFn,\n  DropPosition,\n} from \"./lib/tree-types\";\nimport { TreeViewProvider } from \"./lib/tree-context\";\nimport { useTreeState } from \"./hooks/use-tree-state\";\nimport { useTreeKeyboard } from \"./hooks/use-tree-keyboard\";\nimport { useTreeLazy } from \"./hooks/use-tree-lazy\";\nimport { useTreeDnd } from \"./hooks/use-tree-dnd\";\nimport { TreeNodeRow } from \"./components/tree-node\";\nimport { TreeDropIndicator } from \"./components/tree-drop-indicator\";\n\n// ---------- TreeView Props ----------\n\nexport interface TreeViewProps<T extends TreeNodeData = TreeNodeData>\n  extends Omit<React.ComponentProps<\"div\">, \"onChange\" | \"onDragStart\" | \"onDragEnd\" | \"onDragOver\"> {\n  /** Tree data in nested format */\n  items: TreeNodeNested<T>[];\n  /** Called when tree structure changes (reorder, DND) */\n  onItemsChange?: (items: TreeNodeNested<T>[]) => void;\n  /** Unique ID for this tree instance (auto-generated if not provided) */\n  treeId?: string;\n  /** Render function for each tree node */\n  renderNode: (props: TreeNodeRenderProps<T>) => React.ReactNode;\n  /** Render function for the drag overlay */\n  renderDragOverlay?: (props: TreeNodeRenderProps<T>) => React.ReactNode;\n  /** Async function to load children on expand */\n  loadChildren?: LoadChildrenFn<T>;\n  /** Error callback for lazy loading failures */\n  onLoadError?: (nodeId: string, error: Error) => void;\n  /** Selection mode */\n  selectionMode?: \"none\" | \"single\" | \"multiple\";\n  /** Controlled selected IDs */\n  selectedIds?: string[];\n  /** Selection change callback */\n  onSelectedIdsChange?: (ids: string[]) => void;\n  /** Controlled expanded IDs */\n  expandedIds?: string[];\n  /** Expansion change callback */\n  onExpandedIdsChange?: (ids: string[]) => void;\n  /** Expand all by default */\n  defaultExpandAll?: boolean;\n  /** Specific IDs to expand by default */\n  defaultExpandedIds?: string[];\n  /** Enable drag */\n  draggable?: boolean;\n  /** Enable drop */\n  droppable?: boolean;\n  /** Per-node drag guard */\n  canDrag?: (node: FlatTreeNode<T>) => boolean;\n  /** Per-operation drop guard */\n  canDrop?: (event: TreeDragEvent<T>) => boolean;\n  /** Auto-expand nodes on drag hover */\n  expandOnDragHover?: boolean;\n  /** Delay before auto-expand (ms) */\n  expandOnDragHoverDelay?: number;\n  /** Pixels per indent level */\n  indentationWidth?: number;\n  /** DND event callbacks */\n  onDragStart?: (event: TreeDragEvent<T>) => void;\n  onDragEnd?: (event: TreeDragEvent<T>) => void;\n}\n\n// ---------- TreeView Component ----------\n\nexport function TreeView<T extends TreeNodeData = TreeNodeData>({\n  items,\n  onItemsChange,\n  treeId: treeIdProp,\n  renderNode,\n  renderDragOverlay,\n  loadChildren,\n  onLoadError,\n  selectionMode = \"single\",\n  selectedIds: selectedIdsProp,\n  onSelectedIdsChange,\n  expandedIds: expandedIdsProp,\n  onExpandedIdsChange,\n  defaultExpandAll,\n  defaultExpandedIds,\n  draggable = false,\n  droppable = false,\n  canDrag,\n  canDrop,\n  expandOnDragHover = true,\n  expandOnDragHoverDelay = 500,\n  indentationWidth = 20,\n  onDragStart,\n  onDragEnd,\n  className,\n  ...divProps\n}: TreeViewProps<T>) {\n  const autoId = useId();\n  const treeId = treeIdProp ?? autoId;\n\n  // Core state\n  const state = useTreeState<T>({\n    items,\n    onItemsChange,\n    selectionMode,\n    selectedIds: selectedIdsProp,\n    onSelectedIdsChange,\n    expandedIds: expandedIdsProp,\n    onExpandedIdsChange,\n    defaultExpandAll,\n    defaultExpandedIds,\n  });\n\n  // Lazy loading\n  const lazy = useTreeLazy<T>({\n    loadChildren,\n    insertChildren: state.insertChildren,\n    expand: state.expand,\n    onLoadError,\n  });\n\n  // DND\n  const dnd = useTreeDnd<T>({\n    treeId,\n    flatNodes: state.flatNodes,\n    visibleNodes: state.visibleNodes,\n    expandedIds: state.expandedIds,\n    indentationWidth,\n    canDrag,\n    canDrop,\n    onItemsChange,\n    onDragStart,\n    onDragEnd,\n    expandOnDragHover,\n    expandOnDragHoverDelay,\n    expand: state.expand,\n  });\n\n  // Override toggleExpand to trigger lazy loading\n  const toggleExpand = useCallback(\n    (id: string) => {\n      const node = state.flatNodes.find((n) => n.id === id);\n      if (node && node.isGroup && !node.childrenLoaded && loadChildren) {\n        lazy.triggerLoad(node);\n      } else {\n        state.toggleExpand(id);\n      }\n    },\n    [state, lazy, loadChildren]\n  );\n\n  // Keyboard navigation\n  const keyboard = useTreeKeyboard<T>({\n    visibleNodes: state.visibleNodes,\n    flatNodes: state.flatNodes,\n    focusedId: state.focusedId,\n    expandedIds: state.expandedIds,\n    setFocused: state.setFocused,\n    toggleExpand,\n    expand: state.expand,\n    collapse: state.collapse,\n    select: state.select,\n    toggleSelect: state.toggleSelect,\n    selectionMode,\n  });\n\n  // Active node for drag overlay\n  const activeNode = dnd.activeId\n    ? state.flatNodes.find((n) => n.id === dnd.activeId) ?? null\n    : null;\n\n  // Context value\n  const contextValue = useMemo(\n    () => ({\n      treeId,\n      flatNodes: state.flatNodes,\n      visibleNodes: state.visibleNodes,\n      expandedIds: state.expandedIds,\n      selectedIds: state.selectedIds,\n      focusedId: state.focusedId,\n      loadingIds: lazy.loadingIds,\n      activeId: dnd.activeId,\n      overId: dnd.overId,\n      dropPosition: dnd.dropPosition,\n      projectedDepth: dnd.projectedDepth,\n      indentationWidth,\n      draggable,\n      droppable,\n      canDrag,\n      toggleExpand,\n      select: state.select,\n      setFocused: state.setFocused,\n      renderNode,\n      renderDragOverlay,\n    }),\n    [\n      treeId,\n      state.flatNodes,\n      state.visibleNodes,\n      state.expandedIds,\n      state.selectedIds,\n      state.focusedId,\n      lazy.loadingIds,\n      dnd.activeId,\n      dnd.overId,\n      dnd.dropPosition,\n      dnd.projectedDepth,\n      indentationWidth,\n      draggable,\n      droppable,\n      canDrag,\n      toggleExpand,\n      state.select,\n      state.setFocused,\n      renderNode,\n      renderDragOverlay,\n    ]\n  );\n\n  const treeContent = (\n    <TreeViewProvider value={contextValue}>\n      <div\n        {...divProps}\n        role=\"tree\"\n        aria-label={divProps[\"aria-label\"]}\n        aria-labelledby={divProps[\"aria-labelledby\"]}\n        aria-multiselectable={selectionMode === \"multiple\" || undefined}\n        aria-activedescendant={\n          state.focusedId\n            ? `${treeId}-node-${state.focusedId}`\n            : undefined\n        }\n        tabIndex={0}\n        data-slot=\"tree-view\"\n        className={cn(\"outline-none\", className)}\n        onKeyDown={keyboard.onKeyDown}\n      >\n        {state.visibleNodes.map((node, idx) => (\n          <TreeNodeRow<T>\n            key={node.id}\n            node={node}\n            sortableIndex={idx}\n          />\n        ))}\n      </div>\n    </TreeViewProvider>\n  );\n\n  // Wrap with DragDropProvider if DND is enabled\n  if (draggable || droppable) {\n    return (\n      <DragDropProvider\n        onDragStart={dnd.handleDragStart}\n        onDragOver={dnd.handleDragOver}\n        onDragEnd={dnd.handleDragEnd}\n      >\n        {treeContent}\n        {renderDragOverlay && activeNode && (\n          <DragOverlay>\n            {renderDragOverlay({\n              node: activeNode,\n              isExpanded: state.expandedIds.has(activeNode.id),\n              isSelected: state.selectedIds.has(activeNode.id),\n              isFocused: false,\n              isLoading: false,\n              isDragging: true,\n              isDropTarget: false,\n              dropPosition: null,\n              depth: activeNode.depth,\n              hasChildren: activeNode.isGroup,\n              toggle: () => {},\n              select: () => {},\n            })}\n          </DragOverlay>\n        )}\n      </DragDropProvider>\n    );\n  }\n\n  return treeContent;\n}\n\n// ---------- TreeViewDndContext ----------\n\nexport interface TreeViewDndContextProps {\n  children: React.ReactNode;\n  onDragStart?: (event: { operation: { source: unknown; target: unknown } }) => void;\n  onDragOver?: (event: { operation: { source: unknown; target: unknown } }) => void;\n  onDragEnd?: (event: { operation: { source: unknown; target: unknown }; canceled: boolean }) => void;\n}\n\n/**\n * Wraps multiple TreeView instances to enable cross-tree drag-and-drop.\n * When using this, individual TreeView instances should NOT set `draggable`/`droppable` directly —\n * instead, configure DND at this level.\n */\nexport function TreeViewDndContext({\n  children,\n  onDragStart,\n  onDragOver,\n  onDragEnd,\n}: TreeViewDndContextProps) {\n  return (\n    <DragDropProvider\n      onDragStart={onDragStart}\n      onDragOver={onDragOver}\n      onDragEnd={onDragEnd}\n    >\n      {children}\n    </DragDropProvider>\n  );\n}\n\n// Re-export types for consumers\nexport type {\n  TreeNodeData,\n  TreeNodeNested,\n  FlatTreeNode,\n  TreeDragEvent,\n  TreeNodeRenderProps,\n  LoadChildrenFn,\n  DropPosition,\n} from \"./lib/tree-types\";\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/tree-view/components/tree-node.tsx",
      "content": "\"use client\";\n\nimport { useSortable } from \"@dnd-kit/react/sortable\";\nimport { cn } from \"@/lib/utils\";\nimport { useTreeViewContext } from \"../lib/tree-context\";\nimport type { TreeNodeData, FlatTreeNode } from \"../lib/tree-types\";\n\ninterface TreeNodeRowProps<T extends TreeNodeData = TreeNodeData> {\n  node: FlatTreeNode<T>;\n  sortableIndex: number;\n}\n\nexport function TreeNodeRow<T extends TreeNodeData = TreeNodeData>({\n  node,\n  sortableIndex,\n}: TreeNodeRowProps<T>) {\n  const ctx = useTreeViewContext<T>();\n  const {\n    treeId,\n    flatNodes,\n    expandedIds,\n    selectedIds,\n    focusedId,\n    loadingIds,\n    activeId,\n    overId,\n    dropPosition,\n    indentationWidth,\n    draggable: isDraggableTree,\n    canDrag,\n    toggleExpand,\n    select,\n    renderNode,\n  } = ctx;\n\n  const isExpanded = expandedIds.has(node.id);\n  const isSelected = selectedIds.has(node.id);\n  const isFocused = focusedId === node.id;\n  const isLoading = loadingIds.has(node.id);\n  const isDragging = activeId === node.id;\n  const isDropTargetNode = overId === node.id;\n  const currentDropPosition = isDropTargetNode ? dropPosition : null;\n\n  const hasChildren =\n    node.isGroup &&\n    (node.childrenLoaded\n      ? flatNodes.some((n) => n.parentId === node.id)\n      : true);\n\n  const isDragDisabled =\n    !isDraggableTree || (canDrag ? !canDrag(node) : false);\n\n  // Count siblings for aria-setsize\n  const siblingCount = flatNodes.filter(\n    (n) => n.parentId === node.parentId\n  ).length;\n\n  const {\n    ref,\n    isDragSource,\n  } = useSortable({\n    id: node.id,\n    index: sortableIndex,\n    group: treeId,\n    disabled: isDragDisabled,\n    data: { node, treeId },\n  });\n\n  return (\n    <div\n      ref={ref}\n      role=\"treeitem\"\n      id={`${treeId}-node-${node.id}`}\n      aria-expanded={node.isGroup ? isExpanded : undefined}\n      aria-selected={isSelected}\n      aria-level={node.depth + 1}\n      aria-setsize={siblingCount}\n      aria-posinset={node.index + 1}\n      data-slot=\"tree-node\"\n      data-node-id={node.id}\n      data-depth={node.depth}\n      data-dragging={isDragSource || undefined}\n      data-drop-target={isDropTargetNode || undefined}\n      data-drop-position={currentDropPosition}\n      className={cn(\n        \"relative outline-none\",\n        isDragSource && \"opacity-50\"\n      )}\n    >\n      {renderNode({\n        node,\n        isExpanded,\n        isSelected,\n        isFocused,\n        isLoading,\n        isDragging: isDragSource,\n        isDropTarget: isDropTargetNode,\n        dropPosition: currentDropPosition,\n        depth: node.depth,\n        hasChildren,\n        toggle: () => toggleExpand(node.id),\n        select: () => select(node.id),\n      })}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/tree-view/components/tree-drop-indicator.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\n\ninterface TreeDropIndicatorProps {\n  depth: number;\n  indentationWidth: number;\n  className?: string;\n}\n\nexport function TreeDropIndicator({\n  depth,\n  indentationWidth,\n  className,\n}: TreeDropIndicatorProps) {\n  return (\n    <div\n      data-slot=\"tree-drop-indicator\"\n      className={cn(\"pointer-events-none absolute right-0 bottom-0 h-0.5 bg-primary\", className)}\n      style={{\n        left: depth * indentationWidth,\n      }}\n    />\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-state.ts",
      "content": "\"use client\";\n\nimport { useState, useMemo, useCallback, useRef, useEffect } from \"react\";\nimport type { TreeNodeData, TreeNodeNested, FlatTreeNode } from \"../lib/tree-types\";\nimport {\n  flattenTree,\n  buildTree,\n  getVisibleNodes,\n  getDescendantIds,\n} from \"../lib/tree-utils\";\n\nexport interface UseTreeStateOptions<T extends TreeNodeData> {\n  items: TreeNodeNested<T>[];\n  onItemsChange?: (items: TreeNodeNested<T>[]) => void;\n  selectionMode?: \"none\" | \"single\" | \"multiple\";\n  selectedIds?: string[];\n  onSelectedIdsChange?: (ids: string[]) => void;\n  expandedIds?: string[];\n  onExpandedIdsChange?: (ids: string[]) => void;\n  defaultExpandAll?: boolean;\n  defaultExpandedIds?: string[];\n}\n\nexport interface UseTreeStateReturn<T extends TreeNodeData> {\n  flatNodes: FlatTreeNode<T>[];\n  visibleNodes: FlatTreeNode<T>[];\n  expandedIds: Set<string>;\n  selectedIds: Set<string>;\n  focusedId: string | null;\n  toggleExpand: (id: string) => void;\n  expand: (id: string) => void;\n  collapse: (id: string) => void;\n  select: (id: string) => void;\n  toggleSelect: (id: string) => void;\n  setFocused: (id: string | null) => void;\n  setFlatNodes: (nodes: FlatTreeNode<T>[]) => void;\n  insertChildren: (parentId: string, children: TreeNodeNested<T>[]) => void;\n}\n\nfunction collectAllGroupIds<T extends TreeNodeData>(\n  nodes: TreeNodeNested<T>[]\n): string[] {\n  const ids: string[] = [];\n  for (const node of nodes) {\n    if (node.isGroup || (node.children && node.children.length > 0)) {\n      ids.push(node.id);\n    }\n    if (node.children) {\n      ids.push(...collectAllGroupIds(node.children));\n    }\n  }\n  return ids;\n}\n\nexport function useTreeState<T extends TreeNodeData>(\n  options: UseTreeStateOptions<T>\n): UseTreeStateReturn<T> {\n  const {\n    items,\n    onItemsChange,\n    selectionMode = \"none\",\n    selectedIds: controlledSelectedIds,\n    onSelectedIdsChange,\n    expandedIds: controlledExpandedIds,\n    onExpandedIdsChange,\n    defaultExpandAll = false,\n    defaultExpandedIds,\n  } = options;\n\n  // Flatten input items\n  const flatNodes = useMemo(() => flattenTree(items), [items]);\n\n  // Expanded state (controlled or uncontrolled)\n  const [internalExpandedIds, setInternalExpandedIds] = useState<Set<string>>(\n    () => {\n      if (defaultExpandAll) {\n        return new Set(collectAllGroupIds(items));\n      }\n      if (defaultExpandedIds) {\n        return new Set(defaultExpandedIds);\n      }\n      return new Set<string>();\n    }\n  );\n\n  const expandedIds = controlledExpandedIds\n    ? new Set(controlledExpandedIds)\n    : internalExpandedIds;\n\n  const setExpandedIds = useCallback(\n    (updater: Set<string> | ((prev: Set<string>) => Set<string>)) => {\n      const next = typeof updater === \"function\" ? updater(expandedIds) : updater;\n      if (onExpandedIdsChange) {\n        onExpandedIdsChange(Array.from(next));\n      }\n      if (!controlledExpandedIds) {\n        setInternalExpandedIds(next);\n      }\n    },\n    [expandedIds, onExpandedIdsChange, controlledExpandedIds]\n  );\n\n  // Selected state (controlled or uncontrolled)\n  const [internalSelectedIds, setInternalSelectedIds] = useState<Set<string>>(\n    new Set()\n  );\n\n  const selectedIds = controlledSelectedIds\n    ? new Set(controlledSelectedIds)\n    : internalSelectedIds;\n\n  const setSelectedIds = useCallback(\n    (updater: Set<string> | ((prev: Set<string>) => Set<string>)) => {\n      const next = typeof updater === \"function\" ? updater(selectedIds) : updater;\n      if (onSelectedIdsChange) {\n        onSelectedIdsChange(Array.from(next));\n      }\n      if (!controlledSelectedIds) {\n        setInternalSelectedIds(next);\n      }\n    },\n    [selectedIds, onSelectedIdsChange, controlledSelectedIds]\n  );\n\n  // Focused state\n  const [focusedId, setFocused] = useState<string | null>(null);\n\n  // Visible nodes (derived)\n  const visibleNodes = useMemo(\n    () => getVisibleNodes(flatNodes, expandedIds),\n    [flatNodes, expandedIds]\n  );\n\n  // Actions\n  const toggleExpand = useCallback(\n    (id: string) => {\n      setExpandedIds((prev) => {\n        const next = new Set(prev);\n        if (next.has(id)) {\n          next.delete(id);\n          // Also collapse descendants\n          const descendants = getDescendantIds(flatNodes, id);\n          for (const d of descendants) next.delete(d);\n        } else {\n          next.add(id);\n        }\n        return next;\n      });\n    },\n    [flatNodes, setExpandedIds]\n  );\n\n  const expand = useCallback(\n    (id: string) => {\n      setExpandedIds((prev) => {\n        if (prev.has(id)) return prev;\n        const next = new Set(prev);\n        next.add(id);\n        return next;\n      });\n    },\n    [setExpandedIds]\n  );\n\n  const collapse = useCallback(\n    (id: string) => {\n      setExpandedIds((prev) => {\n        if (!prev.has(id)) return prev;\n        const next = new Set(prev);\n        next.delete(id);\n        const descendants = getDescendantIds(flatNodes, id);\n        for (const d of descendants) next.delete(d);\n        return next;\n      });\n    },\n    [flatNodes, setExpandedIds]\n  );\n\n  const select = useCallback(\n    (id: string) => {\n      if (selectionMode === \"none\") return;\n      if (selectionMode === \"single\") {\n        setSelectedIds(new Set([id]));\n      } else {\n        setSelectedIds(new Set([id]));\n      }\n    },\n    [selectionMode, setSelectedIds]\n  );\n\n  const toggleSelect = useCallback(\n    (id: string) => {\n      if (selectionMode === \"none\") return;\n      if (selectionMode === \"single\") {\n        setSelectedIds((prev) =>\n          prev.has(id) ? new Set() : new Set([id])\n        );\n      } else {\n        setSelectedIds((prev) => {\n          const next = new Set(prev);\n          if (next.has(id)) {\n            next.delete(id);\n          } else {\n            next.add(id);\n          }\n          return next;\n        });\n      }\n    },\n    [selectionMode, setSelectedIds]\n  );\n\n  // Mutation methods for DND and lazy loading\n  const onItemsChangeRef = useRef(onItemsChange);\n  onItemsChangeRef.current = onItemsChange;\n\n  const setFlatNodes = useCallback(\n    (nodes: FlatTreeNode<T>[]) => {\n      if (onItemsChangeRef.current) {\n        onItemsChangeRef.current(buildTree(nodes));\n      }\n    },\n    []\n  );\n\n  const insertChildren = useCallback(\n    (parentId: string, children: TreeNodeNested<T>[]) => {\n      // Rebuild items with children inserted under the parent\n      function insertInto(\n        nodes: TreeNodeNested<T>[]\n      ): TreeNodeNested<T>[] {\n        return nodes.map((node) => {\n          if (node.id === parentId) {\n            return {\n              ...node,\n              children: [...(node.children ?? []), ...children],\n            };\n          }\n          if (node.children) {\n            return { ...node, children: insertInto(node.children) };\n          }\n          return node;\n        });\n      }\n\n      if (onItemsChangeRef.current) {\n        onItemsChangeRef.current(insertInto(items));\n      }\n    },\n    [items]\n  );\n\n  // Auto-focus first visible node when no focus is set\n  useEffect(() => {\n    if (focusedId === null && visibleNodes.length > 0) {\n      setFocused(visibleNodes[0].id);\n    }\n  }, [focusedId, visibleNodes]);\n\n  return {\n    flatNodes,\n    visibleNodes,\n    expandedIds,\n    selectedIds,\n    focusedId,\n    toggleExpand,\n    expand,\n    collapse,\n    select,\n    toggleSelect,\n    setFocused,\n    setFlatNodes,\n    insertChildren,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-keyboard.ts",
      "content": "\"use client\";\n\nimport { useCallback, useRef } from \"react\";\nimport type { TreeNodeData, FlatTreeNode } from \"../lib/tree-types\";\n\nexport interface UseTreeKeyboardOptions<T extends TreeNodeData> {\n  visibleNodes: FlatTreeNode<T>[];\n  flatNodes: FlatTreeNode<T>[];\n  focusedId: string | null;\n  expandedIds: Set<string>;\n  setFocused: (id: string | null) => void;\n  toggleExpand: (id: string) => void;\n  expand: (id: string) => void;\n  collapse: (id: string) => void;\n  select: (id: string) => void;\n  toggleSelect: (id: string) => void;\n  selectionMode: \"none\" | \"single\" | \"multiple\";\n}\n\nexport function useTreeKeyboard<T extends TreeNodeData>(\n  options: UseTreeKeyboardOptions<T>\n): { onKeyDown: React.KeyboardEventHandler } {\n  const optionsRef = useRef(options);\n  optionsRef.current = options;\n\n  // Type-ahead buffer\n  const typeAheadBuffer = useRef(\"\");\n  const typeAheadTimer = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n\n  const onKeyDown: React.KeyboardEventHandler = useCallback((e) => {\n    const {\n      visibleNodes,\n      flatNodes,\n      focusedId,\n      expandedIds,\n      setFocused,\n      toggleExpand,\n      expand,\n      collapse,\n      select,\n      toggleSelect,\n      selectionMode,\n    } = optionsRef.current;\n\n    if (visibleNodes.length === 0) return;\n\n    const currentIndex = focusedId\n      ? visibleNodes.findIndex((n) => n.id === focusedId)\n      : -1;\n    const currentNode =\n      currentIndex >= 0 ? visibleNodes[currentIndex] : null;\n\n    switch (e.key) {\n      case \"ArrowDown\": {\n        e.preventDefault();\n        const nextIndex = Math.min(\n          currentIndex + 1,\n          visibleNodes.length - 1\n        );\n        setFocused(visibleNodes[nextIndex].id);\n        break;\n      }\n\n      case \"ArrowUp\": {\n        e.preventDefault();\n        const prevIndex = Math.max(currentIndex - 1, 0);\n        setFocused(visibleNodes[prevIndex].id);\n        break;\n      }\n\n      case \"ArrowRight\": {\n        e.preventDefault();\n        if (!currentNode) break;\n        if (currentNode.isGroup && !expandedIds.has(currentNode.id)) {\n          // Expand the node\n          expand(currentNode.id);\n        } else if (currentNode.isGroup && expandedIds.has(currentNode.id)) {\n          // Move to first child\n          const nextIndex = currentIndex + 1;\n          if (\n            nextIndex < visibleNodes.length &&\n            visibleNodes[nextIndex].parentId === currentNode.id\n          ) {\n            setFocused(visibleNodes[nextIndex].id);\n          }\n        }\n        break;\n      }\n\n      case \"ArrowLeft\": {\n        e.preventDefault();\n        if (!currentNode) break;\n        if (currentNode.isGroup && expandedIds.has(currentNode.id)) {\n          // Collapse the node\n          collapse(currentNode.id);\n        } else if (currentNode.parentId !== null) {\n          // Move focus to parent\n          setFocused(currentNode.parentId);\n        }\n        break;\n      }\n\n      case \"Home\": {\n        e.preventDefault();\n        if (visibleNodes.length > 0) {\n          setFocused(visibleNodes[0].id);\n        }\n        break;\n      }\n\n      case \"End\": {\n        e.preventDefault();\n        if (visibleNodes.length > 0) {\n          setFocused(visibleNodes[visibleNodes.length - 1].id);\n        }\n        break;\n      }\n\n      case \"Enter\": {\n        e.preventDefault();\n        if (currentNode) {\n          select(currentNode.id);\n        }\n        break;\n      }\n\n      case \" \": {\n        e.preventDefault();\n        if (currentNode) {\n          if (selectionMode === \"multiple\") {\n            toggleSelect(currentNode.id);\n          } else {\n            select(currentNode.id);\n          }\n        }\n        break;\n      }\n\n      case \"*\": {\n        // Expand all siblings of the focused node\n        e.preventDefault();\n        if (!currentNode) break;\n        for (const node of flatNodes) {\n          if (\n            node.parentId === currentNode.parentId &&\n            node.isGroup\n          ) {\n            expand(node.id);\n          }\n        }\n        break;\n      }\n\n      default: {\n        // Type-ahead: single character\n        if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {\n          e.preventDefault();\n          clearTimeout(typeAheadTimer.current);\n          typeAheadBuffer.current += e.key.toLowerCase();\n\n          typeAheadTimer.current = setTimeout(() => {\n            typeAheadBuffer.current = \"\";\n          }, 500);\n\n          // Search from current position forward, wrapping around\n          const startIndex = currentIndex + 1;\n          for (let i = 0; i < visibleNodes.length; i++) {\n            const idx = (startIndex + i) % visibleNodes.length;\n            const node = visibleNodes[idx];\n            // Use a simple heuristic: check if any string value in data starts with the buffer\n            const label = getNodeLabel(node);\n            if (label.toLowerCase().startsWith(typeAheadBuffer.current)) {\n              setFocused(node.id);\n              break;\n            }\n          }\n        }\n        break;\n      }\n    }\n  }, []);\n\n  return { onKeyDown };\n}\n\n/**\n * Best-effort label extraction from node data for type-ahead.\n */\nfunction getNodeLabel<T extends TreeNodeData>(node: FlatTreeNode<T>): string {\n  const data = node.data as Record<string, unknown>;\n  // Try common label fields\n  for (const key of [\"label\", \"name\", \"title\", \"text\"]) {\n    if (typeof data[key] === \"string\") return data[key];\n  }\n  // Fallback to first string value\n  for (const value of Object.values(data)) {\n    if (typeof value === \"string\") return value;\n  }\n  return node.id;\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-dnd.ts",
      "content": "\"use client\";\n\nimport { useState, useCallback, useRef } from \"react\";\nimport type {\n  TreeNodeData,\n  FlatTreeNode,\n  DropPosition,\n  TreeDragEvent,\n} from \"../lib/tree-types\";\nimport {\n  getVisibleNodes,\n  getDescendantIds,\n  getProjection,\n  removeNodes,\n  buildTree,\n} from \"../lib/tree-utils\";\nimport type {\n  DragStartEvent,\n  DragOverEvent,\n  DragEndEvent,\n} from \"@dnd-kit/react\";\n\nexport interface UseTreeDndOptions<T extends TreeNodeData> {\n  treeId: string;\n  flatNodes: FlatTreeNode<T>[];\n  visibleNodes: FlatTreeNode<T>[];\n  expandedIds: Set<string>;\n  indentationWidth: number;\n  canDrag?: (node: FlatTreeNode<T>) => boolean;\n  canDrop?: (event: TreeDragEvent<T>) => boolean;\n  onItemsChange?: (items: import(\"../lib/tree-types\").TreeNodeNested<T>[]) => void;\n  onDragStart?: (event: TreeDragEvent<T>) => void;\n  onDragEnd?: (event: TreeDragEvent<T>) => void;\n  expandOnDragHover?: boolean;\n  expandOnDragHoverDelay?: number;\n  expand: (id: string) => void;\n}\n\nexport interface UseTreeDndReturn {\n  activeId: string | null;\n  overId: string | null;\n  dropPosition: DropPosition | null;\n  projectedDepth: number | null;\n  projectedParentId: string | null;\n  handleDragStart: DragStartEvent;\n  handleDragOver: DragOverEvent;\n  handleDragEnd: DragEndEvent;\n}\n\nexport function useTreeDnd<T extends TreeNodeData>(\n  options: UseTreeDndOptions<T>\n): UseTreeDndReturn {\n  const {\n    treeId,\n    flatNodes,\n    visibleNodes,\n    expandedIds,\n    indentationWidth,\n    canDrop,\n    onItemsChange,\n    onDragStart,\n    onDragEnd,\n    expandOnDragHover = true,\n    expandOnDragHoverDelay = 500,\n    expand,\n  } = options;\n\n  const [activeId, setActiveId] = useState<string | null>(null);\n  const [overId, setOverId] = useState<string | null>(null);\n  const [dropPosition, setDropPosition] = useState<DropPosition | null>(null);\n  const [projectedDepth, setProjectedDepth] = useState<number | null>(null);\n  const [projectedParentId, setProjectedParentId] = useState<string | null>(\n    null\n  );\n\n  const hoverTimerRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  const hoverTargetRef = useRef<string | null>(null);\n  const offsetRef = useRef({ x: 0, y: 0 });\n\n  const handleDragStart: DragStartEvent = useCallback(\n    (event) => {\n      const source = event.operation.source;\n      if (!source) return;\n\n      const sourceNode = flatNodes.find((n) => n.id === source.id);\n      if (!sourceNode) return;\n\n      setActiveId(String(source.id));\n      offsetRef.current = { x: 0, y: 0 };\n\n      if (onDragStart && sourceNode) {\n        onDragStart({\n          source: sourceNode,\n          sourceTreeId: treeId,\n          target: sourceNode,\n          targetTreeId: treeId,\n          position: \"before\",\n          projectedDepth: sourceNode.depth,\n        });\n      }\n    },\n    [flatNodes, treeId, onDragStart]\n  );\n\n  const handleDragOver: DragOverEvent = useCallback(\n    (event) => {\n      const { source, target } = event.operation;\n      if (!source || !target) {\n        setOverId(null);\n        setDropPosition(null);\n        return;\n      }\n\n      const targetId = String(target.id);\n      setOverId(targetId);\n\n      // Track cumulative offset for depth projection\n      const transform = event.operation.transform;\n      if (transform) {\n        offsetRef.current = { x: transform.x, y: transform.y };\n      }\n\n      // Calculate projection\n      const projection = getProjection(\n        flatNodes,\n        visibleNodes,\n        String(source.id),\n        targetId,\n        offsetRef.current.x,\n        indentationWidth\n      );\n\n      setProjectedDepth(projection.depth);\n      setProjectedParentId(projection.parentId);\n\n      // Determine drop position\n      const targetNode = flatNodes.find((n) => n.id === targetId);\n      if (targetNode) {\n        const position: DropPosition =\n          targetNode.isGroup && projection.parentId === targetId\n            ? \"inside\"\n            : \"after\";\n        setDropPosition(position);\n      }\n\n      // Auto-expand on hover\n      if (expandOnDragHover && targetId !== hoverTargetRef.current) {\n        clearTimeout(hoverTimerRef.current);\n        hoverTargetRef.current = targetId;\n\n        const hoverNode = flatNodes.find((n) => n.id === targetId);\n        if (\n          hoverNode?.isGroup &&\n          !expandedIds.has(targetId) &&\n          targetId !== String(source.id)\n        ) {\n          hoverTimerRef.current = setTimeout(() => {\n            expand(targetId);\n          }, expandOnDragHoverDelay);\n        }\n      }\n    },\n    [\n      flatNodes,\n      visibleNodes,\n      indentationWidth,\n      expandedIds,\n      expandOnDragHover,\n      expandOnDragHoverDelay,\n      expand,\n    ]\n  );\n\n  const handleDragEnd: DragEndEvent = useCallback(\n    (event) => {\n      clearTimeout(hoverTimerRef.current);\n      hoverTargetRef.current = null;\n\n      const { source, target } = event.operation;\n      const canceled = event.canceled;\n\n      if (canceled || !source || !target) {\n        setActiveId(null);\n        setOverId(null);\n        setDropPosition(null);\n        setProjectedDepth(null);\n        setProjectedParentId(null);\n        return;\n      }\n\n      const sourceNode = flatNodes.find((n) => n.id === source.id);\n      const targetNode = flatNodes.find((n) => n.id === target.id);\n\n      if (!sourceNode || !targetNode) {\n        setActiveId(null);\n        setOverId(null);\n        setDropPosition(null);\n        return;\n      }\n\n      // Check canDrop\n      const dragEvent: TreeDragEvent<T> = {\n        source: sourceNode,\n        sourceTreeId: treeId,\n        target: targetNode,\n        targetTreeId: treeId,\n        position: dropPosition ?? \"after\",\n        projectedDepth: projectedDepth ?? targetNode.depth,\n      };\n\n      if (canDrop && !canDrop(dragEvent)) {\n        setActiveId(null);\n        setOverId(null);\n        setDropPosition(null);\n        setProjectedDepth(null);\n        setProjectedParentId(null);\n        return;\n      }\n\n      // Perform the move\n      if (onItemsChange) {\n        // Get descendants of the dragged node\n        const descendantIds = getDescendantIds(flatNodes, sourceNode.id);\n        const draggedIds = new Set([sourceNode.id, ...descendantIds]);\n\n        // Collect dragged nodes\n        const draggedNodes = flatNodes.filter((n) => draggedIds.has(n.id));\n\n        // Remove dragged nodes from the tree\n        const remaining = removeNodes(flatNodes, [sourceNode.id]);\n\n        // Calculate target position in the remaining tree\n        const targetParentId = projectedParentId;\n\n        // Update depth and parentId for all dragged nodes\n        const depthDiff = (projectedDepth ?? 0) - sourceNode.depth;\n        const updatedDragged = draggedNodes.map((n) => ({\n          ...n,\n          depth: n.depth + depthDiff,\n          parentId: n.id === sourceNode.id ? targetParentId : n.parentId,\n        }));\n\n        // Insert at the correct position\n        let insertAt = remaining.length;\n        const targetFlatIdx = remaining.findIndex(\n          (n) => n.id === target.id\n        );\n        if (targetFlatIdx >= 0) {\n          // Skip past target's descendants\n          let i = targetFlatIdx + 1;\n          while (\n            i < remaining.length &&\n            remaining[i].depth > remaining[targetFlatIdx].depth\n          ) {\n            i++;\n          }\n          insertAt = i;\n        }\n\n        const result = [\n          ...remaining.slice(0, insertAt),\n          ...updatedDragged,\n          ...remaining.slice(insertAt),\n        ];\n\n        onItemsChange(buildTree(result));\n      }\n\n      if (onDragEnd) {\n        onDragEnd(dragEvent);\n      }\n\n      setActiveId(null);\n      setOverId(null);\n      setDropPosition(null);\n      setProjectedDepth(null);\n      setProjectedParentId(null);\n    },\n    [\n      flatNodes,\n      treeId,\n      dropPosition,\n      projectedDepth,\n      projectedParentId,\n      expandedIds,\n      canDrop,\n      onItemsChange,\n      onDragEnd,\n    ]\n  );\n\n  return {\n    activeId,\n    overId,\n    dropPosition,\n    projectedDepth,\n    projectedParentId,\n    handleDragStart,\n    handleDragOver,\n    handleDragEnd,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/hooks/use-tree-lazy.ts",
      "content": "\"use client\";\n\nimport { useState, useCallback, useRef } from \"react\";\nimport type {\n  TreeNodeData,\n  TreeNodeNested,\n  FlatTreeNode,\n  LoadChildrenFn,\n} from \"../lib/tree-types\";\n\nexport interface UseTreeLazyOptions<T extends TreeNodeData> {\n  loadChildren?: LoadChildrenFn<T>;\n  insertChildren: (parentId: string, children: TreeNodeNested<T>[]) => void;\n  expand: (id: string) => void;\n  onLoadError?: (nodeId: string, error: Error) => void;\n}\n\nexport interface UseTreeLazyReturn {\n  loadingIds: Set<string>;\n  isLoading: (id: string) => boolean;\n  triggerLoad: (node: FlatTreeNode) => void;\n}\n\nexport function useTreeLazy<T extends TreeNodeData>(\n  options: UseTreeLazyOptions<T>\n): UseTreeLazyReturn {\n  const { loadChildren, insertChildren, expand, onLoadError } = options;\n  const [loadingIds, setLoadingIds] = useState<Set<string>>(new Set());\n  const inFlightRef = useRef<Set<string>>(new Set());\n\n  const isLoading = useCallback(\n    (id: string) => loadingIds.has(id),\n    [loadingIds]\n  );\n\n  const triggerLoad = useCallback(\n    (node: FlatTreeNode) => {\n      if (!loadChildren) return;\n      if (!node.isGroup) return;\n      if (node.childrenLoaded) return;\n      if (inFlightRef.current.has(node.id)) return;\n\n      inFlightRef.current.add(node.id);\n      setLoadingIds((prev) => {\n        const next = new Set(prev);\n        next.add(node.id);\n        return next;\n      });\n\n      loadChildren(node as FlatTreeNode<T>)\n        .then((children) => {\n          insertChildren(node.id, children);\n          expand(node.id);\n        })\n        .catch((error) => {\n          if (onLoadError) {\n            onLoadError(\n              node.id,\n              error instanceof Error ? error : new Error(String(error))\n            );\n          }\n        })\n        .finally(() => {\n          inFlightRef.current.delete(node.id);\n          setLoadingIds((prev) => {\n            const next = new Set(prev);\n            next.delete(node.id);\n            return next;\n          });\n        });\n    },\n    [loadChildren, insertChildren, expand, onLoadError]\n  );\n\n  return { loadingIds, isLoading, triggerLoad };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/tree-view/lib/tree-types.ts",
      "content": "/**\n * Base constraint for user-provided tree node data.\n * Users extend this with their own properties.\n * Using an object constraint to allow interfaces without index signatures.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport type TreeNodeData = {};\n\n/**\n * Nested input format — what users pass as tree data.\n */\nexport interface TreeNodeNested<T extends TreeNodeData = TreeNodeData> {\n  /** Unique identifier for this node */\n  id: string;\n  /** Custom user data */\n  data: T;\n  /** Whether this node can have children (shows expand affordance even when empty) */\n  isGroup?: boolean;\n  /** Child nodes. Omit or undefined for lazy-loaded groups. */\n  children?: TreeNodeNested<T>[];\n}\n\n/**\n * Internal flat representation used by the tree engine.\n */\nexport interface FlatTreeNode<T extends TreeNodeData = TreeNodeData> {\n  id: string;\n  data: T;\n  isGroup: boolean;\n  /** Whether children have been loaded (for lazy loading). true if children array was provided. */\n  childrenLoaded: boolean;\n  parentId: string | null;\n  depth: number;\n  /** Position among siblings (0-based) */\n  index: number;\n}\n\n/**\n * Drop position relative to a target node.\n */\nexport type DropPosition = \"before\" | \"after\" | \"inside\";\n\n/**\n * Information passed to DND event handlers.\n */\nexport interface TreeDragEvent<T extends TreeNodeData = TreeNodeData> {\n  /** The node being dragged */\n  source: FlatTreeNode<T>;\n  /** The source tree instance id */\n  sourceTreeId: string;\n  /** The target node (drop target) */\n  target: FlatTreeNode<T>;\n  /** The target tree instance id */\n  targetTreeId: string;\n  /** Where relative to target */\n  position: DropPosition;\n  /** Projected depth after drop */\n  projectedDepth: number;\n}\n\n/**\n * Callback for lazy loading children.\n */\nexport type LoadChildrenFn<T extends TreeNodeData = TreeNodeData> = (\n  node: FlatTreeNode<T>\n) => Promise<TreeNodeNested<T>[]>;\n\n/**\n * Render function props for custom node rendering.\n */\nexport interface TreeNodeRenderProps<T extends TreeNodeData = TreeNodeData> {\n  node: FlatTreeNode<T>;\n  isExpanded: boolean;\n  isSelected: boolean;\n  isFocused: boolean;\n  isLoading: boolean;\n  isDragging: boolean;\n  isDropTarget: boolean;\n  dropPosition: DropPosition | null;\n  depth: number;\n  hasChildren: boolean;\n  toggle: () => void;\n  select: () => void;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/tree-view/lib/tree-utils.ts",
      "content": "import type { TreeNodeData, TreeNodeNested, FlatTreeNode } from \"./tree-types\";\n\n/**\n * Convert nested tree structure to flat array with parentId references.\n */\nexport function flattenTree<T extends TreeNodeData>(\n  nodes: TreeNodeNested<T>[],\n  parentId: string | null = null,\n  depth: number = 0\n): FlatTreeNode<T>[] {\n  const result: FlatTreeNode<T>[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const hasChildren = node.children !== undefined && node.children.length > 0;\n\n    result.push({\n      id: node.id,\n      data: node.data,\n      isGroup: node.isGroup ?? hasChildren,\n      childrenLoaded: node.children !== undefined,\n      parentId,\n      depth,\n      index: i,\n    });\n\n    if (node.children) {\n      result.push(...flattenTree(node.children, node.id, depth + 1));\n    }\n  }\n\n  return result;\n}\n\n/**\n * Convert flat array back to nested tree structure.\n */\nexport function buildTree<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[]\n): TreeNodeNested<T>[] {\n  const nodeMap = new Map<\n    string,\n    TreeNodeNested<T> & { _hasChildren: boolean }\n  >();\n  const roots: TreeNodeNested<T>[] = [];\n\n  // Create all nodes first\n  for (const flat of flatNodes) {\n    nodeMap.set(flat.id, {\n      id: flat.id,\n      data: flat.data,\n      isGroup: flat.isGroup || undefined,\n      children: flat.childrenLoaded ? [] : undefined,\n      _hasChildren: false,\n    });\n  }\n\n  // Build parent-child relationships\n  for (const flat of flatNodes) {\n    const node = nodeMap.get(flat.id)!;\n    // Remove internal marker\n    const { _hasChildren: _, ...cleanNode } = node;\n\n    if (flat.parentId === null) {\n      roots.push(cleanNode);\n    } else {\n      const parent = nodeMap.get(flat.parentId);\n      if (parent) {\n        if (!parent.children) parent.children = [];\n        parent.children.push(cleanNode);\n        parent._hasChildren = true;\n      }\n    }\n  }\n\n  return roots;\n}\n\n/**\n * Get only the visible nodes (ancestors all expanded).\n */\nexport function getVisibleNodes<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  expandedIds: Set<string>\n): FlatTreeNode<T>[] {\n  const result: FlatTreeNode<T>[] = [];\n  const collapsedAncestors = new Set<string>();\n\n  for (const node of flatNodes) {\n    // Skip if any ancestor is collapsed\n    if (node.parentId !== null && collapsedAncestors.has(node.parentId)) {\n      // This node is hidden; if it's a group, its descendants are also hidden\n      collapsedAncestors.add(node.id);\n      continue;\n    }\n\n    result.push(node);\n\n    // If this node is a group and not expanded, mark it as collapsed ancestor\n    if (node.isGroup && !expandedIds.has(node.id)) {\n      collapsedAncestors.add(node.id);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Get all descendant IDs of a node.\n */\nexport function getDescendantIds<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  parentId: string\n): string[] {\n  const descendants: string[] = [];\n  const parentSet = new Set<string>([parentId]);\n\n  for (const node of flatNodes) {\n    if (node.parentId !== null && parentSet.has(node.parentId)) {\n      descendants.push(node.id);\n      parentSet.add(node.id);\n    }\n  }\n\n  return descendants;\n}\n\n/**\n * Get all ancestor IDs of a node (from immediate parent to root).\n */\nexport function getAncestorIds<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  nodeId: string\n): string[] {\n  const ancestors: string[] = [];\n  const nodeMap = new Map<string, FlatTreeNode<T>>();\n\n  for (const node of flatNodes) {\n    nodeMap.set(node.id, node);\n  }\n\n  let current = nodeMap.get(nodeId);\n  while (current && current.parentId !== null) {\n    ancestors.push(current.parentId);\n    current = nodeMap.get(current.parentId);\n  }\n\n  return ancestors;\n}\n\n/**\n * Get the count of siblings for a node (nodes with the same parentId).\n */\nexport function getSiblingCount<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  parentId: string | null\n): number {\n  let count = 0;\n  for (const node of flatNodes) {\n    if (node.parentId === parentId) count++;\n  }\n  return count;\n}\n\n/**\n * Calculate the projected depth and parentId for a DND drop operation.\n * Based on horizontal cursor offset from the active item's original position.\n */\nexport function getProjection<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  visibleNodes: FlatTreeNode<T>[],\n  activeId: string,\n  overId: string,\n  offsetX: number,\n  indentWidth: number\n): { depth: number; parentId: string | null } {\n  const overIndex = visibleNodes.findIndex((n) => n.id === overId);\n  const activeNode = flatNodes.find((n) => n.id === activeId);\n\n  if (overIndex === -1 || !activeNode) {\n    return { depth: 0, parentId: null };\n  }\n\n  const overNode = visibleNodes[overIndex];\n  const depthDelta = Math.round(offsetX / indentWidth);\n  const projectedDepth = Math.max(0, activeNode.depth + depthDelta);\n\n  // Clamp the projected depth based on surrounding nodes\n  const nextNode = visibleNodes[overIndex + 1];\n  const maxDepth = overNode.isGroup\n    ? overNode.depth + 1\n    : overNode.depth;\n  const minDepth = nextNode ? nextNode.depth : 0;\n  const clampedDepth = Math.min(Math.max(projectedDepth, minDepth), maxDepth);\n\n  // Find the parent at the projected depth\n  let parentId: string | null = null;\n  if (clampedDepth > 0) {\n    // Walk backwards from overNode to find a node at (clampedDepth - 1) that could be parent\n    for (let i = overIndex; i >= 0; i--) {\n      if (visibleNodes[i].depth === clampedDepth - 1) {\n        parentId = visibleNodes[i].id;\n        break;\n      }\n    }\n  }\n\n  return { depth: clampedDepth, parentId };\n}\n\n/**\n * Remove nodes by IDs (and all their descendants).\n */\nexport function removeNodes<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  ids: string[]\n): FlatTreeNode<T>[] {\n  const removeSet = new Set(ids);\n\n  // Also collect all descendants of removed nodes\n  for (const node of flatNodes) {\n    if (node.parentId !== null && removeSet.has(node.parentId)) {\n      removeSet.add(node.id);\n    }\n  }\n\n  const result = flatNodes.filter((n) => !removeSet.has(n.id));\n\n  // Recompute sibling indices\n  return reindexSiblings(result);\n}\n\n/**\n * Insert flat nodes into the tree at a specific position.\n */\nexport function insertNodes<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[],\n  nodesToInsert: FlatTreeNode<T>[],\n  targetParentId: string | null,\n  targetIndex: number\n): FlatTreeNode<T>[] {\n  // Find the insertion point in the flat array\n  let insertAt = flatNodes.length; // default: end\n\n  // Find position of the target sibling\n  let siblingCount = 0;\n  for (let i = 0; i < flatNodes.length; i++) {\n    if (flatNodes[i].parentId === targetParentId) {\n      if (siblingCount === targetIndex) {\n        insertAt = i;\n        break;\n      }\n      siblingCount++;\n    }\n  }\n\n  const result = [\n    ...flatNodes.slice(0, insertAt),\n    ...nodesToInsert,\n    ...flatNodes.slice(insertAt),\n  ];\n\n  return reindexSiblings(result);\n}\n\n/**\n * Recompute sibling indices after structural changes.\n */\nfunction reindexSiblings<T extends TreeNodeData>(\n  flatNodes: FlatTreeNode<T>[]\n): FlatTreeNode<T>[] {\n  const indexCounters = new Map<string | null, number>();\n\n  return flatNodes.map((node) => {\n    const key = node.parentId;\n    const currentIndex = indexCounters.get(key) ?? 0;\n    indexCounters.set(key, currentIndex + 1);\n    return { ...node, index: currentIndex };\n  });\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/tree-view/lib/tree-context.ts",
      "content": "\"use client\";\n\nimport { createContext, useContext } from \"react\";\nimport type {\n  TreeNodeData,\n  FlatTreeNode,\n  DropPosition,\n} from \"./tree-types\";\n\n/**\n * Internal context for a single TreeView instance.\n * Shared between TreeView and its TreeNode children.\n */\nexport interface TreeViewContextValue<\n  T extends TreeNodeData = TreeNodeData,\n> {\n  treeId: string;\n  flatNodes: FlatTreeNode<T>[];\n  visibleNodes: FlatTreeNode<T>[];\n  expandedIds: Set<string>;\n  selectedIds: Set<string>;\n  focusedId: string | null;\n  loadingIds: Set<string>;\n  activeId: string | null;\n  overId: string | null;\n  dropPosition: DropPosition | null;\n  projectedDepth: number | null;\n  indentationWidth: number;\n  draggable: boolean;\n  droppable: boolean;\n  canDrag?: (node: FlatTreeNode<T>) => boolean;\n  toggleExpand: (id: string) => void;\n  select: (id: string) => void;\n  setFocused: (id: string | null) => void;\n  renderNode: (props: import(\"./tree-types\").TreeNodeRenderProps<T>) => React.ReactNode;\n  renderDragOverlay?: (props: import(\"./tree-types\").TreeNodeRenderProps<T>) => React.ReactNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst TreeViewContext = createContext<TreeViewContextValue<any> | null>(null);\n\nexport const TreeViewProvider = TreeViewContext.Provider;\n\nexport function useTreeViewContext<\n  T extends TreeNodeData = TreeNodeData,\n>(): TreeViewContextValue<T> {\n  const ctx = useContext(TreeViewContext);\n  if (!ctx) {\n    throw new Error(\"useTreeViewContext must be used within a <TreeView>\");\n  }\n  return ctx as TreeViewContextValue<T>;\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}
